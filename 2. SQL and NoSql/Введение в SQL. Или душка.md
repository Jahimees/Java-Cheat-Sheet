# Введение

Реляционные базы данных представляют собой базы данных, которые используются для хранения и предоставления доступа к взаимосвязанным элементам информации. 
Реляционные базы данных основаны на реляционной модели — интуитивно понятном, наглядном табличном способе представления данных. 
Каждая строка, содержащая в таблице такой базы данных, представляет собой запись с уникальным идентификатором, который называют ключом. 
Столбцы таблицы имеют атрибуты данных, а каждая запись обычно содержит значение для каждого атрибута, что дает возможность легко устанавливать взаимосвязь между элементами данных.

Здорово, но нихрена не понятно. Для начала разберемся с тем, что такое база данных.

База данных — это систематический сбор данных, хранящихся в электронном виде. 
Она может содержать любые типы данных, включая слова, цифры, изображения, видео и файлы. 

**Для хранения, извлечения и редактирования данных можно использовать программное обеспечение, называемое системой управления базами данных (СУБД).**

Простыми словами: база данных - хранилище, в котором хранится информация о чем-либо. 
Когда говорят "база данных", то скорее всего имеют структурированное хранилище, где данные хранятся по определенным правилам в инфомрационном виде.
Можно провести анологию из жизни, чтобы было понятно. 

Представим, что мы владеем каким-нибудь салоном красоты. К нам постоянно ходят клиенты. 
Чтобы проводить акции для постоянных клиентов, то мы должны хранить где-то данные о клиентах. Используем для этой цели, например, блокнот.
В блокноте будет таблица, где мы указываем имя, фамилию, номер телефона, дату рождения. Каждый новый клиент будет занимать одну строку. Таким образом, мы собираем базу постоянных клиентов.
По большому счету, это уже можно считать базой данных, только на физическом носителе, что, согласитесь, не очень удобно. Тоже самое можно делать в таблице excel. Уже удобнее, но все равно не совсем то.
Например, мы ведем учет всех услуг, которые мы предоставляем. Записей может быть сотни, тысячи, десятки тысяч! Excel вряд ли подойдет для этой цели.
Вот для этого и нужны базы данных: они хранят необходимые нам данные и обеспечивают простой и удобный доступ к этим данных.

Вот как обычно работает БД в контексте приложения

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/fffe1590-8b03-47d6-be70-3869a7e8ae9b)

## Основные понятия

Для того, чтобы ориентироваться в SQL, нам необходимо знать, что вообще входит в SQL помимо понятия База данных. Пойдем от большого к малому.

База Данных -> Таблица -> Запись (кортеж) -> Столбец (поле).

Итак, база данных состоит из таблиц. Если проводить анологию с Java или ООП, то таблица очень похожа на класс, только без методов. Суть вот в чем:
Таблица - строго определенная структура, хранящая данные в соответствии с этой структурой. Под структурой понимается набор полей, которые определяют сущность таблицы.
Чтобы понять, что из себя представляет таблица, приведем пример:

У нас есть человек, некоторая персона. На какие характеристики можно разделить человека, чтобы получить описание какого-то отдельного человека?

Ну например: пол, возраст, фамилия, имя, цвет глаз, форма лица, цвет волос, прическа и так далее.
Так вот, набор этих полей и формирует структуру самой **таблицы** (прямо как класс и его поля).

А когда мы добавляем конкретного человека в таблицу (мужчина, 42 года, Пупкин, Вася, зеленый цвет глаз, овальное лицо, шатен, ирокез...), то это уже **называется записью, или кортежем.** 
И это очень похоже на объект класса.

В целом, заполненная таблица выглядит примерно так как и обычная таблица: 

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/6e9ee9ac-10c0-43d5-90d4-fb4f355a47e7)

И, соответственно, поля - конкретные характеристики в таблице.

## В чем же тогда отличие базы данных от реляционной базы данных?

Реляционная база данных — набор таблиц, хранящихся в одном пространстве. Пока непонятно. Но должно стать немного понятнее, когда мы попытаемся понять семантику слова **Реляционная**.
Слово реляционная происходит от слова relational - относительный... Не совсем понятно. В данном случае под понятием "относительный" понимаются некие "отношения".

И наша схема немного преобразуется: База Данных -> Таблица -> Отношение -> Запись (кортеж) -> Столбец (поле).

### Отношения кого с кем?

Суть реляционной модели заключается в том, что таблицы в такой базе данных каким-то образом связаны друг с другом, причем, как правило, все таблицы связаны. 

Если у нас 3 связанные таблиц, то это не значит, что каждая связана с каждой, это значит, что мы можем из любой таблицы "дойти" до любой другой таблице "по стрелочкам" (в любом направлении, стрелки - не указатели направления, об этом позже):

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/be2d6d64-ac06-499f-9338-26944726cfc5)

Таблицы связываются друг с другом по каким-то полям. Как правило - это идентификаторы - поля, которые хранят уникальные значения, по которым можно однозначно идентифицировать запись.
Представьте, что у вас в базе данных 2 одинаковых человека: два Васи Пупкина. А кого конкретно нам нужно взять? По какому принципу их разделить?

Для этого и нужны идентификаторы, или первичные ключи.

Первичный (primary) ключ - поле, либо набор полей, однозначно определяющие запись. 
Причем первичным ключом не обязательно должен быть id (идентификатор), это может быть какая-то **уникальная информация об объекте** (номер паспорта например), 
либо **набор полей**, совокупность которых также однозначно определит сущность (вряд ли вы встретите Васю Пупкина Васильевича с зеленым цветом глаз, брюнета со шрамом на правой руке. По отдельности эти данные могут подойти многим, но в совокупности они определяют конкретного человека).

Вернемся к отношениям и взглянем на рисунок:

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/77d3cf90-00e9-48a3-9adc-16499e6e1129)

Что у нас есть?
* 4 таблицы
* В главной таблице Car из информативного у нас лишь колонка year
* Непонятные связи

На самом деле, в данном примере присутствует ошибка, о которой чуть позже. А пока пойдем от простого.

Взгляните на таблицу Color. В ней мы видим два поля:
* color_id
* color_name
И три записи:
* 1 - Red
* 2 - Green
* 3 - Blue
В данном случае, колонка color_id помогает нам однозначно идентифицировать цвет. Мы сами сказали, что 1 - это красный, 2 - это зеленый, а 3 - это синий. Условно, мы установили такое правило.
И теперь, когда мы скажем "дай мне из таблицы Color цвет, который соответствует id=3" и нам вернут "Синий".

Теперь посмотрим на ту же колонку в таблице Car. Что мы видим?
_Вместо самого цвета, там указывается его id!_ Тем самым образуется связь с таблицей Color.
То есть, если, по логике, взглянуть на таблицу Car и вместо всех id подставить соответствующие значения, то получится вполне внятная картина и остальные таблицы будут не нужны!
Как бы дааа, но как бы нет. Не просто же так мы понадобавляли кучу таблиц!

Представьте, что случится, если, например в таблице Brand будет не 2 поля, а 32! А в Model_Brand - 10, а в Color - 5! Получается, что наша таблица Car бы разрослась до вселенских масштабов! Нехорошо...
А так, у нас есть просто ссылки на нужные записи! Плюс ко всему, не будет дублирования информации! Зачем нам повторять 300 раз слово "Красный"? Тем более, что мы можем написать это по-разному:
* Красный
* КрАсНыЙ
* КРАСНы
* Крсный
И человек поймет, что все это - одно и то же. Но когда мы будем пытаться найти красную машину, то как это сделать правильно? Мы написали все по разному... А когда мы используем что-то вроде "ссылки", то мы уже точно знаем, что таких косяков не будет.

Кстати, поле **color_id** в таблице **Car** называется **Внешним (foreign) ключом**, поскольку именно с этим полем связывается таблица Color.
Таким образом, для установления отношения нам необходимо 2 таблицы. В каждой таблице должно быть поле, которое связывается с полем другой таблицы. **Как правило, primary_key связывается с foreign_key.**

### Виды отношений

#### Один ко многим

Теперь нам стало понятно, что отношения - это связи между таблицами по определенным полям. Но что насчет вариативности отношений?
Рассмотрим все тот же пример с машиной и ее цветом. Давайте подумаем логически...

Одна машина может иметь единовременно только **ОДИН** цвет.
При этом, один цвет может принадлежать **МНОГИМ** машинам. (когда вы идете по улице, вы видите множество ЧЕРНЫХ машин.)

Такая связь называется **ОДИН ко МНОГИМ**.

Вот еще пример с таблицами Model_Brand и Brand.
Бренд - это что-то более большое, чем модель. При этом модель неразрывно связяна с брендом.

у бренда может быть МНОЖЕСТВО моделей.
Но модель может принадлежать лишь ОДНОМУ бренду.

Надеюсь понятно. Так вот как такие связи отображаются:

Там где у нас ОДИН, мы ставим небольшую точку, а там где у нас МНОЖЕСТВО - мы рисуем стрелку (на самом деле все зависит от нотации, в которой рисуется модель, главное помнить, где нарисовано меньше - там один, где больше - множество ;) )

#### Один к одному

Тип связи Один к одному, обычно, используется когда вы разделили одну таблицу на две.
Например:

У нас есть аккаунт, в котором есть логин, пароль и так далее.
Также у нас есть пользователь, у которого есть ФИО, дата рождения и так далее.

Система предусматривает, что у ОДНОГО пользователя может быть только ОДИН аккаунт. В теории, мы бы могли записать все в одну таблицу, но это было бы неудобно из-за громоздкости.

#### Многие ко многим

Если вы видите такую связь на работе, то знайте - кто-то криворукий кретин. Об этом чуть позже. А пока пример:

Возьмем те же машины. Представим, что мы добавляем таблицу Person - человек, который будет владеть машинами. Какая может быть построена связь?

Один человек может владеть МНОЖЕСТВОМ машин.
При этом одна и та же машина (имеется в виду ее тип, цвет. А не физическая) может быть у МНОЖЕСТВА людей (Черный Volkswagen passat 2003 года есть у меня и у моего знакомого и еще у пары тысяч людей).

Как это можно разделить?

Путем добавления промежуточной таблицы, которая будет выступать эдаким "буфером":

Пусть есть таблицы М1 и М2 (м - многие)
Было:

М1 - М2

Стало:

М1 - О - М2

Таким образом, мы получим 3 таблицы, которые связаны между собой связями один ко многим. Как это выглядит на практике?
В нашем примере с машинами мы можем добавить Машина_Человека. И внутри этой таблицы будут просто внешние ключи к соответствующим человеку и машине. Когда дойдет до практики - станет понятно.
Пока - держите эту информацию в голове.
