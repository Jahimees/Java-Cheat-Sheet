_Источники_
_https://habr.com/ru/articles/745910/_
_https://javarush.com/groups/posts/1878-mnogopotochnostjh-v-java_
_https://habr.com/ru/articles/164487/_

## Введение. Основные понятия

**Процесс** - это экземпляр выполняющейся программы, простыми словами при запуске любой программы на вашем компьютере, вы порождаете процесс. Он имеет свое собственное адресное пространство памяти и один или несколько потоков.

Process (процесс) – выполняющийся экземпляр программы, которому Операционная Система (ОС) выделила память, процессорное время/ядра и прочие ресурсы. Важно, что память выделяется отдельно, адресные пространства различных процессов недоступны друг другу. Если процессам необходимо обмениваться данными, они могут это сделать с помощью файлов, каналов и иных способов межпроцессного взаимодействия.

**Поток** - это последовательность инструкций, выполняющаяся внутри процесса. Потоки делят адресное пространство памяти процесса, что позволяет им работать параллельно.

Java Thread (поток). Иногда, чтобы не путать с другими классами Java – Stream и подобными, потоки Java часто переводят как нить. Они используют выделенные для процесса ресурсы и являются способом выполнения процесса. Главный поток выполняет метод main и завершается. При выполнении процесса могут порождаться дополнительные потоки (дочерние). Потоки одного процесса могут между собой обмениваться данными. Многопоточность Java требует учитывать синхронизацию данных, не забывайте об этом.

В Java процесс завершается тогда, когда закончил работу последний его поток. Для фоновых задач поток можно запустить как демон (daemon), отличие которого от обычного в том, что они будут принудительно завершены при окончании работы всех не-daemon потоков процесса. 

**Внутри** ПРОЦЕССА может быть множество ПОТОКОВ.

На самом деле потоки не работают параллельно друг другу. Программа выделяет потокам определенное процессорное время, в которое поток будет работать. То есть, потоки работают поочередно, просто меняются между собой очень-очень быстро.

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/cc405d93-6e93-4079-9897-2f2d5254f3e2)


## Состояния потока

Каждый поток пребывает в одном из следующих состояний (state):
* Создан (New) – очередь к кадровику готовится, люди организуются.
* Запущен (Runnable) – наша очередь выстроилась к кадровику и обрабатывается.
* Заблокирован (Blocked) – последний в очереди юноша пытается выкрикнуть имя, но услышав, что девушка в соседней группе начала делать это раньше него, замолчал.
* Завершён (Terminated) — вся очередь оформилась у кадровика и в ней нет необходимости.
* Ожидает(Waiting) – одна очередь ждёт сигнала от другой.

Организация потоков и их взаимодействие – это основа эффективной работы процессов.

## Базовые способы запуска потоков

Каждый процесс имеет хотя бы один выполняющийся поток. Тот поток, с которого начинается выполнение программы, называется главным. В языке Java, после создания процесса, выполнение главного потока начинается с метода main(). Затем, по мере необходимости, в заданных программистом местах, и при выполнении заданных им же условий, запускаются другие, побочные потоки.

Существует более полудюжины способов создания потоков. Для начала познакомимся базовыми.

### Способ 1

**Создать объект класса Thread, передав ему в конструкторе нечто, реализующее интерфейс Runnable/Callable. Этот интерфейс содержит метод run(), который будет выполняться в новом потоке. Поток закончит выполнение, когда завершится его метод run().**
* Runnable — нет возвращаемого значения, нельзя пробросить checked-исключение.
* Callable — возвращает Future, может кидать исключения.

    class SomeThing implements Runnable { //Нечто, реализующее интерфейс Runnable (содержащее метод run())
	    public void run() { //Этот метод будет выполняться в побочном потоке
		    System.out.println("Привет из побочного потока!");
    	}
    }

    public class Program { //Класс с методом main()
	    static SomeThing mThing;	//mThing - объект класса, реализующего интерфейс Runnable
	
	    public static void main(String[] args) {
		    mThing = new SomeThing();				
    
        Thread myThready = new Thread(mThing);	//Создание потока "myThready"
		    myThready.start();				//Запуск потока

		    System.out.println("Главный поток завершён...");
	    }
    }

!Для понимания того, что будет происходить дальше необходимо знать следующие понятия!
* [Анонимные классы](https://github.com/Jahimees/Java-Cheat-Sheet/blob/main/Java/%D0%A7%D0%B0%D1%81%D1%82%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B5%D0%BC%D1%8B/%D0%90%D0%BD%D0%BE%D0%BD%D0%B8%D0%BC%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B.md)
* [Лямбды](https://github.com/Jahimees/Java-Cheat-Sheet/blob/main/Java/%D0%A7%D0%B0%D1%81%D1%82%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B5%D0%BC%D1%8B/Stream%20%D0%B8%20lambda.md)

В случае, если мы знаем, что инструкции в классе SomeThing нам понадобятся всего 1 раз, то мы можем не плодить новый класс, а передать в new Thread(...) анонимный класс:

      public class Program {

          public static void main(String[] args) {
          
              Thread myThread = new Thread(new Runnable() {
              
                  public void run() {
                     System.out.println("Привет из побочного потока!");
                  }
              });

              myThread.start();
          }
      }

Далее, вспомним, что класс Runnable является функциональным, что дает нам возможность использовать лямбда:

      public class Program {

          public static void main(String[] args) {
              Thread myThread = new Thread(() -> System.out.println("Привет из побочного потока!"));
              myThread.start();
          }
      }

### Способ 2

**Создать потомка класса Thread и переопределить его метод run():**

Имеется специальный класс **Thread** в методе **run()** которого необходимо написать код, реализующий логику программы. После создания потока, можно запустить его, вызвав метод **start**().

Напишем демонстрационную программу, реализующую пример многопоточности  Java.

    class PeopleQueue extends Thread    {// Наша очередь из сотрудников, наследник класса Thread
      private String[] names;

      PeopleQueue(String... names) {// Конструктор, аргумент- массив имен сотрудников
          this.names = names;
      }

      @Override
      public void run() { // Этот метод будет вызван при старте потока
          for (int i = 0; i < names.length; i++) { // Вывод в цикле с паузой 0.5 сек очередного сотрудника
              System.out.println("Обработаны документы: " + names[i]);
              try {
                  sleep(500); // Задержка в 0.5 сек
              } catch (Exception e) {}
          }
      }
    }

    public class HR    {// Класс для демонстрации работы потока
      public static void main(String[] args) {
          // Создаем две очереди
          PeopleQueue queue1 = new PeopleQueue("Иван","Сергей","Николай","Фердинанд","Василий");
          PeopleQueue queue2 = new PeopleQueue("Мария","Людмила","Алиса","Карина","Ольга");

          System.out.println("Начали!"); // Сообщение из главного потока программы
          queue1.start();    //Запускаем одну очередь (дочерний поток)
          queue2.start(); //Запускаем вторую (дочерний поток)
      }
    }

## Демонстрация работы потоков

Для демонстрации параллельной работы потоков давайте рассмотрим программу, в которой два потока спорят на предмет философского вопроса «что было раньше, яйцо или курица?». Главный поток уверен, что первой была курица, о чем он и будет сообщать каждую секунду. Второй же поток раз в секунду будет опровергать своего оппонента. Всего спор продлится 5 секунд. Победит тот поток, который последним изречет свой ответ на этот, без сомнения, животрепещущий философский вопрос. В примере используются средства, о которых пока не было сказано (isAlive() sleep() и join()). К ним даны комментарии, а более подробно они будут разобраны дальше.

    class EggVoice extends Thread {
	    @Override
	    public void run() {
		    for(int i = 0; i < 5; i++) {
			    try {
				    sleep(1000);		//Приостанавливает поток на 1 секунду
			    } catch(InterruptedException e) {}
			
			    System.out.println("яйцо!");	
		    }
		    //Слово «яйцо» сказано 5 раз
	    }
    }

    public class ChickenVoice	{ //Класс с методом main()
	    static EggVoice mAnotherOpinion;	//Побочный поток
	
	    public static void main(String[] args) {
		    mAnotherOpinion = new EggVoice();	//Создание потока
		    System.out.println("Спор начат...");
		    mAnotherOpinion.start(); 			//Запуск потока
		
		    for(int i = 0; i < 5; i++) {
			    try {
				    Thread.sleep(1000);		//Приостанавливает поток на 1 секунду
			    } catch(InterruptedException e){}
			
			    System.out.println("курица!");
		    }		
		    //Слово «курица» сказано 5 раз
      
        if (mAnotherOpinion.isAlive()) { //Если оппонент еще не сказал последнее слово
			  try {  
				    mAnotherOpinion.join();	//Подождать пока оппонент закончит высказываться.
			  } catch(InterruptedException e) {}
			
			    System.out.println("Первым появилось яйцо!");
		    } else {	//если оппонент уже закончил высказываться
					System.out.println("Первой появилась курица!");
		    }
		    System.out.println("Спор закончен!");	
	    }
    }

    Консоль (Результат заранее непредсказуем):
    Спор начат...
    курица!
    яйцо!
    яйцо!
    курица!
    яйцо!
    курица!
    яйцо!
    курица!
    яйцо!
    курица!
    Первой появилась курица!
    Спор закончен!

Как было подмечено, заранее результат непредсказуем. Это происходит из-за так называемого «асинхронного выполнения кода». Асинхронность означает то, что нельзя утверждать, что какая-либо инструкция одного потока, выполнится раньше или позже инструкции другого. Или, другими словами, параллельные потоки независимы друг от друга, за исключением тех случаев, когда программист сам описывает зависимости между потоками с помощью предусмотренных для этого средств языка.

## Завершение потоков и демоны

В Java процесс завершается тогда, когда завершается последний его поток. Даже если метод main() уже завершился, но еще выполняются порожденные им потоки, система будет ждать их завершения.

Однако это правило не относится к особому виду потоков – **демонам**. Если завершился последний обычный поток процесса, и остались только потоки-демоны, то они будут принудительно завершены и выполнение процесса закончится. Чаще всего потоки-демоны используются для выполнения фоновых задач, обслуживающих процесс в течение его жизни.

Объявить поток демоном достаточно просто — нужно перед запуском потока вызвать его метод **setDaemon(true);**
Проверить, является ли поток демоном, можно вызвав его метод boolean **isDaemon();**

### Завершение потоков

В Java существуют (существовали) средства для принудительного завершения потока. В частности метод **Thread.stop()** завершает поток незамедлительно после своего выполнения. Однако этот метод, а также **Thread.suspend()**, приостанавливающий поток, и **Thread.resume()**, продолжающий выполнение потока, были объявлены устаревшими и **их использование отныне крайне нежелательно**. _Дело в том что поток может быть «убит» во время выполнения операции, обрыв которой на полуслове оставит некоторый объект в неправильном состоянии, что приведет к появлению трудноотлавливаемой и случайным образом возникающей ошибке._

Вместо принудительного завершения потока применяется схема, в которой каждый поток сам ответственен за своё завершение. Поток может остановиться либо тогда, когда он закончит выполнение метода run(), (main() — для главного потока) либо по сигналу из другого потока. Причем как реагировать на такой сигнал — дело, опять же, самого потока. Получив его, поток может выполнить некоторые операции и завершить выполнение, а может и вовсе его проигнорировать и продолжить выполняться. Описание реакции на сигнал завершения потока лежит на плечах программиста.

Java имеет встроенный механизм оповещения потока, который называется Interruption (прерывание, вмешательство), и скоро мы его рассмотрим, но сначала посмотрите на следующую программку:

Incremenator — поток, который каждую секунду прибавляет или вычитает единицу из значения статической переменной Program.mValue. Incremenator содержит два закрытых поля – mIsIncrement и mFinish. То, какое действие выполняется, определяется булевой переменной mIsIncrement — если оно равно true, то выполняется прибавление единицы, иначе — вычитание. А завершение потока происходит, когда значение mFinish становится равно true.

    class Incremenator extends Thread {
	    //О ключевом слове volatile - чуть ниже
	    private volatile boolean mIsIncrement = true;
	    private volatile boolean mFinish = false;

	    public void changeAction() { //Меняет действие на противоположное
		    mIsIncrement = !mIsIncrement;
	    }
     
	    public void finish() { //Инициирует завершение потока
		    mFinish = true;
	    }

	    @Override
	    public void run() {
		    do {
			    if(!mFinish) { //Проверка на необходимость завершения	
				    if(mIsIncrement) {
					    Program.mValue++;	//Инкремент
            } else {
					    Program.mValue--;	//Декремент
            }
    				
				    //Вывод текущего значения переменной
				    System.out.print(Program.mValue + " ");
			    } else return;		//Завершение потока

			    try{
				    Thread.sleep(1000);		//Приостановка потока на 1 сек.
			    } catch(InterruptedException e){}
		    } while(true); 
	    }
    }

    public class Program {
	    //Переменая, которой оперирует инкременатор
	    public static int mValue = 0;
	
	    static Incremenator mInc;	//Объект побочного потока

	    public static void main(String[] args) {
		    mInc = new Incremenator();	//Создание потока
		
		    System.out.print("Значение = ");
		
		    mInc.start();	//Запуск потока
		
		    //Троекратное изменение действия инкременатора
		    //с интервалом в i*2 секунд
		    for(int i = 1; i <= 3; i++) {
			    try {
				    Thread.sleep(i*2*1000); //Ожидание в течении i*2 сек.
			    } catch(InterruptedException e){}
			
			    mInc.changeAction();	//Переключение действия
		    }
		
		    mInc.finish();	//Инициация завершения побочного потока	
	    }
    }

    Консоль:
    Значение = 1 2 1 0 -1 -2 -1 0 1 2 3 4

Взаимодействовать с потоком можно с помощью метода **changeAction**() (для смены вычитания на сложение и наоборот) и метода **finish**() (для завершения потока).

В объявлении переменных **mIsIncrement** и **mFinish** было использовано ключевое слово **_volatile_** (изменчивый, не постоянный). _Его необходимо использовать для переменных, которые используются разными потоками_. Это связано с тем, что значение переменной, объявленной без volatile, может кэшироваться отдельно для каждого потока, и значение из этого кэша может различаться для каждого из них. 

**Объявление переменной с ключевым словом volatile отключает для неё такое кэширование и все запросы к переменной будут направляться непосредственно в память.** 

В этом примере показано, каким образом можно организовать взаимодействие между потоками. Однако есть одна проблема при таком подходе к завершению потока — Incremenator проверяет значение поля mFinish раз в секунду, поэтому может пройти до секунды времени между тем, когда будет выполнен метод finish(), и фактическим завершения потока. Было бы замечательно, если бы при получении сигнала извне, метод sleep() возвращал выполнение и поток незамедлительно начинал своё завершение. Для выполнения такого сценария существует встроенное средство оповещения потока, которое называется **Interruption** (прерывание, вмешательство).

### Interruption

Класс Thread содержит в себе скрытое булево поле, подобное полю mFinish в программе Incremenator, которое называется флагом прерывания. 
* Установить этот флаг можно вызвав метод interrupt() потока.
* Проверить же, установлен ли этот флаг, можно двумя способами.
  * Первый способ — вызвать метод bool isInterrupted() объекта потока,
  * Второй — вызвать статический метод bool Thread.interrupted().

**Первый метод** возвращает состояние флага прерывания и оставляет этот флаг нетронутым. 

**Второй метод** возвращает состояние флага и сбрасывает его. 

**Заметьте что Thread.interrupted()** — статический метод класса Thread, и его вызов возвращает значение флага прерывания того потока, из которого он был вызван. Поэтому этот метод вызывается только изнутри потока и позволяет потоку проверить своё состояние прерывания.

Итак, вернемся к нашей программе. Механизм прерывания позволит нам решить проблему с засыпанием потока. У методов, приостанавливающих выполнение потока, таких как **sleep(), wait() и join() **есть одна особенность — если во время их выполнения будет вызван метод _interrupt_() этого потока, они, не дожидаясь конца времени ожидания, **сгенерируют исключение InterruptedException**.

Переделаем программу Incremenator – теперь вместо завершения потока с помощью метода finish() будем использовать стандартный метод interrupt(). А вместо проверки флага mFinish будем вызывать метод bool Thread.interrupted();

Так будет выглядеть класс Incremenator после добавления поддержки прерываний:

    class Incremenator extends Thread {
	    private volatile boolean mIsIncrement = true;

	    public void changeAction() { //Меняет действие на противоположное
		    mIsIncrement = !mIsIncrement;
	    }

	    @Override
	    public void run() {
		    do {
			    if(!Thread.interrupted()) {	//Проверка прерывания
				    if(mIsIncrement) Program.mValue++;	//Инкремент
				      else Program.mValue--;			//Декремент
				
				    //Вывод текущего значения переменной
				    System.out.print(Program.mValue + " ");
			    } else return;		//Завершение потока	

			    try {
				      Thread.sleep(1000);		//Приостановка потока на 1 сек.
			    } catch(InterruptedException e) {
				      return;	//Завершение потока после прерывания
			    }
		    } while(true); 
	    }
    }

    class Program {
	    //Переменая, которой оперирует инкременатор
	    public static int mValue = 0;
	
	    static Incremenator mInc;	//Объект побочного потока

	    public static void main(String[] args) {
		    mInc = new Incremenator();	//Создание потока
		
		    System.out.print("Значение = ");
		
		    mInc.start();	//Запуск потока
		
		    //Троекратное изменение действия инкременатора
		    //с интервалом в i*2 секунд
		    for(int i = 1; i <= 3; i++) {
			    try{
				    Thread.sleep(i*2*1000);		//Ожидание в течении i*2 сек.
			    } catch(InterruptedException e){}
			
			    mInc.changeAction();	//Переключение действия
		    }
		
		    mInc.interrupt();	//Прерывание побочного потока
	    }
    }

    Консоль:
    Значение = 1 2 1 0 -1 -2 -1 0 1 2 3 4

Заметьте что методы **sleep**() и **join**() обёрнуты в конструкции try-catch. Это необходимое условие работы этих методов. Вызывающий их код должен перехватывать исключение InterruptedException, которое они бросают при прерывании во время ожидания.

# Другие способы запуска потоков

## Через ExecutorService (самый правильный способ)
Почему лучше Thread?

* Потоки создаются и управляются автоматически (пул потоков).
* Нет риска создать 100500 потоков и уронить приложение.
* Есть удобные методы (submit, invokeAll и т.д.).

Основные классы:
* Executors (фабрики пулов):
	* newFixedThreadPool
	* newCachedThreadPool
	* newSingleThreadExecutor
* ExecutorService — управление задачами.
* Future — результат асинхронной задачи.

Примеры:

Фиксированный пул потоков

	ExecutorService executor = Executors.newFixedThreadPool(4); // 4 потока
	executor.submit(() -> {
    		System.out.println("Привет из потока " + Thread.currentThread().getName());
	});

	executor.shutdown(); // завершаем работу пула

  Пул с кешированием (создаёт потоки по мере необходимости)

	ExecutorService executor = Executors.newCachedThreadPool();

	executor.submit(() -> {
		System.out.println("Задача выполняется в " + Thread.currentThread().getName());
	});

	executor.shutdown();
  
  Запуск с возвращаемым значением (Future)

  	ExecutorService executor = Executors.newSingleThreadExecutor();

	Future<Integer> future = executor.submit(() -> {
    		return 42; // возвращаем результат
	});

	System.out.println("Результат: " + future.get()); // ждём и получаем результат

	executor.shutdown();

## Через CompletableFuture (асинхронное программирование)

Почему круто?
* Можно цеплять задачи (thenApply, thenAccept).
* Запускается асинхронно (не блокирует основной поток).
* Поддержка комбинирования нескольких Future.

Примеры:

Простой запуск

	CompletableFuture.runAsync(() -> {
    		System.out.println("Я работаю в фоне!");
	});

Запуск с возвращаемым значением

	CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    		return "Результат вычислений";
	});

	future.thenAccept(result -> System.out.println("Получено: " + result));

Комбинирование Future

	CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> 10);
	CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> 20);

	future1.thenCombine(future2, (a, b) -> a + b)
       		.thenAccept(sum -> System.out.println("Сумма: " + sum));

## Через ForkJoinPool (для параллельных задач)

Почему?
* Оптимален для рекурсивных задач (например, обход дерева).
* Работает по принципу "разделяй и властвуй".

Пример:
	ForkJoinPool pool = new ForkJoinPool();

	pool.invoke(new RecursiveAction() {
    		@Override
    		protected void compute() {
        		System.out.println("Выполняю задачу в ForkJoinPool");
    		}
	});

	pool.shutdown();

## Через Timer и ScheduledExecutorService (отложенный запуск)

Старый способ (Timer)

	Timer timer = new Timer();
	timer.schedule(new TimerTask() {
    		@Override
    		public void run() {
        		System.out.println("Задача выполнилась через 2 секунды");
    		}
	}, 2000); // 2000 мс = 2 сек

Современный способ (ScheduledExecutorService)

	ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

	scheduler.schedule(() -> {
    		System.out.println("Запущено через 3 секунды");
	}, 3, TimeUnit.SECONDS);

	scheduler.shutdown();

## Через ThreadFactory (кастомизация потоков)

Зачем?
* Если нужно настроить создание потоков (имена, приоритеты, демоны и т.д.).

	ThreadFactory factory = new ThreadFactory() {
    		private int count = 0;
    
    		@Override
    		public Thread newThread(Runnable r) {
        		Thread thread = new Thread(r, "CustomThread-" + count++);
        		thread.setPriority(Thread.MAX_PRIORITY);
        		return thread;
    		}
	};

	ExecutorService executor = Executors.newFixedThreadPool(2, factory);
	executor.submit(() -> System.out.println("Я кастомный поток!"));
	executor.shutdown();

# Виртуальные потоки Java 21. Loom

### Проблемы с Thread
* Ограничение ОС: Классические потоки Java — это "тяжёлые" (OS-level) потоки, которые маппятся на потоки ОС (например, в Linux это pthread).
* Максимум потоков: Обычно ОС не позволяет создавать больше ~10_000–30_000 потоков (зависит от настроек ядра).
* Накладные расходы:
	* Каждый поток потребляет ~1 МБ стека (по умолчанию).
	* Переключение контекста между потоками — дорого.
	* Пример: Если у вас 10_000 пользователей, и каждый требует свой поток — сервер упадёт.

 ### Виртуальные потоки

**Что это?**
* Легковесные потоки, которые не привязаны к потокам ОС.
* Управляются JVM, а не ОС.
* Можно создать миллионы виртуальных потоков без нагрузки на систему.

**Как работают?**
* JVM сама планирует их выполнение на небольшом числе реальных потоков.
* Блокировка виртуального потока не блокирует поток ОС (это ключевое преимущество).

Запуск:

	Thread.startVirtualThread(() -> {
    		System.out.println("Привет из виртуального потока!");
	});

ExecutorService:

	ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();

	executor.submit(() -> {
    		System.out.println("Задача в виртуальном потоке");
	});

* ✅ Можно создавать миллионы потоков без нагрузки на ОС.
* ✅ Блокировки больше не страшны:
	* Если виртуальный поток блокируется (например, на I/O), JVM просто переключается на другой виртуальный поток.
	* В классических потоках блокировка потока ОС — это катастрофа для производительности.
* ✅ Совместимость:
	* Виртуальные потоки работают с synchronized, ExecutorService, Future и другими стандартными API.

* ❌ Не все библиотеки готовы:
	* Нативные вызовы (JNI) и некоторые синхронные API могут снижать эффективность.
	* Например, если внутри synchronized блокируется поток ОС, преимущество теряется.
* ❌ Не для CPU-bound задач:
	* Виртуальные потоки не ускоряют вычисления (для этого лучше ForkJoinPool).
	* Они решают проблему множества блокирующих операций (HTTP-запросы, БД и т.д.).

### Continuations и Work-Stealing в Virtual Threads (Java 21+)
Эти две концепции — ключевые для понимания, как виртуальные потоки работают под капотом.

#### Continuations (Продолжения)

**Continuation** — это объект, который хранит состояние выполнения потока (стек вызовов, локальные переменные, позицию в коде).

Позволяет приостановить выполнение кода в любой точке и возобновить его позже.

**Работа:**
1. Блокирующая операция (например, чтение из сети или БД):
	* Виртуальный поток не блокирует поток ОС, а сохраняет своё состояние (continuation).
	* JVM переключается на другую задачу (как в кооперативной многозадачности).
2. Когда операция готова (например, пришли данные):
	* JVM восстанавливает continuation и продолжает выполнение.

	void handleRequest(Request request) {
    		String data = readFromDatabase(); // Блокирующий вызов
    		process(data);
	}

При вызове _readFromDatabase_() виртуальный поток сохраняет состояние (continuation) и освобождает поток ОС.

Когда данные готовы, JVM возобновляет выполнение с места остановки.

### Work-Stealing (кража работы)

Алгоритм, при котором потоки, завершившие свои задачи, могут "украсть" задачи у других потоков.

Используется в ForkJoinPool и теперь — в виртуальных потоках.

Задачи виртуальных потоков выполняются на небольшом числе реальных потоков ОС (например, 16).

Если один поток ОС завершил все свои виртуальные потоки, он берёт задачи из общей очереди (или "ворует" у других потоков).

* **Минимизация простоев**: Потоки ОС всегда заняты.
* **Балансировка нагрузки**: Нет ситуации, когда один поток завален задачами, а другие простаивают.

# Concurrent коллекции

## Интерфейсы
пакет java.util.concurrency расширяет интерфейс очереди для определения новых ADT:

<img width="944" height="490" alt="image" src="https://github.com/user-attachments/assets/a301a677-6a46-4c17-bca3-8cf888629fbd" />

## Реализации

<img width="1321" height="518" alt="image" src="https://github.com/user-attachments/assets/bde0ee60-e8fc-457c-b42e-6b1cd64c206a" />

Все реализации коллекций в пакете java.util.concurrent являются потокобезопасными. В этих реализациях используется fine grained мелкозернистая блокировка/синхронизация для обеспечения потокобезопасности.

[ADT](https://www.logicbig.com/quick-info/software-engineering/abstract-data-type.html) - Abstract data type

| Реализация                | АТД (Абстрактный тип данных) | Структура данных и особенности                                                                                                                                                                                                                                                                                                                                 | Производительность (Big O нотация)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|---------------------------|------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ArrayBlockingQueue        | BlockingQueue                | Массив объектов. Ограниченный размер. Поддерживает политику справедливости. Если `fairness=true`, потоки гарантированно получают доступ в порядке FIFO. Классический ограниченный буфер.                                                                                                                                                                        | `offer`, `peek`, `poll`, `size`: **O(1)**<br>`put`, `take`: **O(1)** (если не учитывать время блокировки).<br>Справедливость обычно снижает пропускную способность, но предотвращает голодание producer/consumer.                                                                                                                                                                                                                                                                                                          |
| LinkedBlockingQueue       | BlockingQueue                | Связанная структура. Опционально ограниченный.                                                                                                                                                                                                                                                                                                                 | `offer`, `peek`, `poll`, `size`: **O(1)**<br>`put`, `take` используют отдельные блокировки, что увеличивает пропускную способность. Ещё выше, если не ограничен (нет блокировки из-за размера).<br>Менее предсказуемая производительность из-за динамического выделения памяти и фрагментации (удерживает блокировки дольше).                                                                                                                                                                                              |
| ConcurrentLinkedQueue     | Queue                        | Связанная структура. Неограниченный. Неблокирующий, но потокобезопасный. Запрещены `null`. Лучший выбор, чем `LinkedBlockingQueue`, когда много потоков обращаются к коллекции.                                                                                                                                                                                | Использует эффективный алгоритм **wait-free**:<br>`offer`, `peek`, `poll`: **O(1)**<br>`size`: **O(n)** (из-за асинхронной природы). Метод `size()` мало полезен в многопоточной среде, так как результат может быть неточным.<br>Итераторы **weakly consistent** (не кидают `ConcurrentModificationException` и не гарантируют актуальность данных).                                                                                                                                                                        |
| DelayQueue                | BlockingQueue                | Внутри использует `PriorityQueue` (куча). Неограниченный. Каждый элемент должен реализовывать `java.util.concurrent.Delayed`. Когда `getDelay()` возвращает `<= 0`, элемент доступен для извлечения, но всё ещё учитывается в `size()`. Запрещены `null`.                                                                                                        | `offer`, `poll`, `remove()`, `add`: **O(log n)**<br>`remove(Object)`, `contains(Object)`: **O(n)**<br>`peek`, `element`, `size`: **O(1)**                                                                                                                                                                                                                                                                                                                                                                                 |
| PriorityBlockingQueue     | BlockingQueue                | Бинарная куча. Неограниченный. Использует натуральный порядок или `Comparator`.                                                                                                                                                                                                                                                                                | `offer`, `poll`, `remove()`, `add`: **O(log n)**<br>`remove(Object)`, `contains(Object)`: **O(n)**<br>`peek`, `element`, `size`: **O(1)**<br>`put`: **O(log n)** (не блокируется, так как очередь неограниченная).<br>`take`: **O(log n)** (блокируется, пока не появится элемент).                                                                                                                                                                                                                                        |
| SynchronousQueue          | BlockingQueue                | Нет стандартной структуры. Реализует шаблон **rendezvous** (передача данных между потоками). Каждая операция вставки ждёт соответствующего удаления другим потоком и наоборот. Нет элементов в хранилище (только передача информации).                                                                                                                          | `put`, `offer`, `take`, `poll`: **O(1)**<br>Другие методы не имеют эффекта: `poll()` всегда возвращает `null`, `isEmpty()` — `false`, `size()` — `0`, `iterator()` — пустой итератор и т.д.                                                                                                                                                                                                                                                                                                                               |
| LinkedTransferQueue       | TransferQueue                | Связанная структура. Неограниченный. Похож на `SynchronousQueue`, но является формальной коллекцией с дополнительными методами (`tryTransfer`, `transfer` и др.). Если в очереди уже есть элементы и вызван `transfer`, он ждёт её опустошения, включая новый переданный элемент.                                                                                | `offer`, `peek`, `poll`: **O(1)**<br>`size`: **O(n)**<br>Все блокирующие методы снижают пропускную способность.<br>Обычно `LinkedTransferQueue` значительно быстрее `SynchronousQueue`.                                                                                                                                                                                                                                                                                                                                     |
| LinkedBlockingDeque       | BlockingDeque                | Двусвязные узлы. Опционально ограниченный. Лучший выбор, чем `LinkedBlockingDeque`, когда много потоков обращаются к коллекции.                                                                                                                                                                                                                                | `remove`, `removeFirstOccurrence`, `removeLastOccurrence`, `contains`, `iterator.remove()` и bulk-операции: **O(n)**<br>Остальные операции: **O(1)** (без учёта блокировки).                                                                                                                                                                                                                                                                                                                                               |
| ConcurrentLinkedDeque     | Deque                        | Двусвязные узлы. Неограниченный. Неблокирующий, но потокобезопасный. Запрещены `null`. Лучший выбор, чем `LinkedBlockingDeque` при многопоточном доступе.                                                                                                                                                                                                     | Индексные `get` и `remove`: **O(n)**<br>`size`: **O(n)** (ненадёжный из-за асинхронности).<br>Остальные методы: **O(1)**.<br>Итераторы **weakly consistent** (не кидают `ConcurrentModificationException`).                                                                                                                                                                                                                                                                                                                |
| CopyOnWriteArrayList      | List                         | Массивы объектов. Потокобезопасный. Все изменяющие методы (`add`, `set` и др.) создают новую копию массива.                                                                                                                                                                                                                                                    | `add`, `contains`, `remove(E e)`: **O(n)**<br>`get(Int index)`, `next`: **O(1)**<br>Блокировка только для записи. Дорогие операции записи (копирование массива).<br>Не рекомендуется при частых случайных изменениях.<br>Итераторы очень быстрые (без блокировок), но не поддерживают `remove`, `set`, `add` (`UnsupportedOperationException`).                                                                                                                                                                              |
| CopyOnWriteArraySet       | Set                          | Массивы объектов (внутри — `CopyOnWriteArrayList` с избеганием дубликатов через `addIfAbsent`). Потокобезопасный.                                                                                                                                                                                                                                             | `add`, `contains`, `remove(E e)`: **O(n)**<br>`next`: **O(1)**<br>Поведение итераторов как у `CopyOnWriteArrayList`.                                                                                                                                                                                                                                                                                                                                                                                                      |
| ConcurrentSkipListSet     | NavigableSet                 | Основан на `ConcurrentSkipListMap` (структура **skip list**), где элементы — ключи мапы. Потокобезопасный. Вставка, удаление и доступ безопасны для многопоточности.                                                                                                                                                                                           | `contains`, `add`, `remove` и их варианты: **O(log n)**<br>`next`: **O(1)**<br>`size`: **O(n)** (ненадёжный из-за асинхронности).<br>Итераторы и сплитераторы **weakly consistent**.                                                                                                                                                                                                                                                                                                                                     |

## Fine-Grained vs. Coarse-Grained Locking
Fine-Grained (мелкозернистая блокировка)
— Использует множество локов для небольших частей данных.
— Плюсы: Высокий параллелизм (меньше contention).
— Минусы: Сложнее реализовать, возможны deadlocks.
Пример: ConcurrentHashMap блокирует отдельные сегменты, а не всю таблицу.

Coarse-Grained (крупнозернистая блокировка)
— Один лок на всю структуру данных.
— Плюсы: Простота реализации.
— Минусы: Низкая параллелизм (высокий contention).
Пример: Hashtable блокирует всю таблицу при операциях.

## Блокирующая vs. Неблокирующая очередь
Блокирующая (Blocking Queue)
— При пустой очереди: take() блокирует поток до появления элемента.
— При полной очереди: put() блокирует поток до освобождения места.
Пример: ArrayBlockingQueue, LinkedBlockingQueue.

Неблокирующая (Non-Blocking Queue)
— Использует атомарные операции (CAS — Compare-And-Swap).
— Потоки не блокируются, а повторяют попытку при конфликте.
Пример: ConcurrentLinkedQueue.

## Голодание (Starvation) Producer/Consumer
Производитель (Producer) — поток, добавляющий данные в очередь.

Потребитель (Consumer) — поток, забирающий данные.

Голодание возникает, когда:
— Производители заполняют очередь, и потребители не успевают её обрабатывать (consumer starvation).
— Или наоборот: потребители опустошают очередь, а производители не могут добавить данные (producer starvation).
Решение: Ограничение размера очереди или политика справедливости.

## Справедливость (Fairness)
Справедливая очередь гарантирует, что потоки получают доступ в порядке FIFO (первым пришёл — первым обслужен).

Несправедливая очередь может обслуживать потоки в произвольном порядке (например, чтобы увеличить throughput).
Пример:
— ArrayBlockingQueue(fair=true) — справедливая.
— SynchronousQueue(fair=false) — может дать преимущество "быстрым" потокам.

Компромисс: Справедливость снижает пропускную способность (throughput), но предотвращает голодание.

**CAS (Compare-And-Swap)** — атомарная операция для неблокирующих алгоритмов.

**Weakly Consistent Iterators** — итераторы, которые могут не отражать последние изменения (например, в ConcurrentHashMap).

**Throughput vs. Latency** — справедливость уменьшает throughput (кол-во операций в секунду), но улучшает latency (время отклика для отдельных потоков).

Пример: take() в ArrayBlockingQueue
Если очередь пуста, поток блокируется (не потребляет CPU).
Когда появляется новый элемент (put() или offer()), один из ждущих потоков пробуждается и забирает элемент.

Что происходит внутри?
    Поток вызывает take().
    Если очередь пуста, поток:
    Захватывает монитор очереди (внутренний ReentrantLock).
    Переходит в режим ожидания (await() на Condition).
    Освобождает монитор (чтобы другие потоки могли добавлять элементы).
    Когда другой поток добавляет элемент (put()), он:
    Захватывает монитор.
    Добавляет элемент.
    Пробуждает один из ждущих потоков (signal() на Condition).
    Поток, который ждал, перехватывает монитор и забирает элемент.

| Критерий |	Блокирующая очередь (ArrayBlockingQueue)	| Неблокирующая очередь (ConcurrentLinkedQueue)  |
|----------|--------------------------------------------|------------------------------------------------|
| Блокировка |	Да (put()/take() ждут)	| Нет (использует CAS-операции) |
| Производительность |	Медленнее (из-за блокировок) |	Быстрее (нет блокировок) |
| Голодание	| Возможно (если fair=false)	| Нет (все потоки конкурируют через CAS) |
| Использование CPU |	Нет (поток спит)	| Да (поток повторяет попытки) |

## Важные моменты
Производительность всех вышеперечисленных реализаций (конкурентных коллекций) связана с блокировками и синхронизацией.
Если коллекцию использует только один поток, лучше выбрать обычные несинхронизированные коллекции из java.util (например, ArrayList вместо CopyOnWriteArrayList).

### Сравнение реализаций:
Очереди на основе связного списка (LinkedBlockingQueue, ConcurrentLinkedQueue)
— Эффективнее обычного LinkedList (который тоже реализует Deque), так как не поддерживают поиск или удаление по индексу (это операции O(n)).

### Сценарии "Producer-Consumer"
— Для двух потоков (один производитель, один потребитель) подходят блокирующие очереди (BlockingQueue).
— Для множества потоков — конкурентные реализации (ConcurrentLinkedQueue, ConcurrentLinkedDeque).

### Почему конкурентные коллекции лучше Collections.synchronizedXYZ()?
Collections.synchronizedList()/synchronizedQueue() синхронизируют все методы на одном общем мониторе (this), что позволяет работать только одному потоку за раз.

Конкурентные коллекции используют мелкозернистые блокировки (например, lock striping в ConcurrentHashMap), что повышает параллелизм.

Когда всё же использовать Collections.synchronizedXYZ()?
— При низкой конкуренции (мало потоков).
— Если нужно гарантировать, что изменения сразу видны всем потокам (strong consistency).
— Важно: При использовании итераторов требуется внешняя синхронизация, иначе возможно ConcurrentModificationException.

### Ключевые выводы

| Ситуация |	Рекомендуемая реализация |	Причина |
|-----|----|----|
| Один поток |	Обычные коллекции (ArrayList) |	Нет накладных расходов на синхронизацию. |
| Producer-Consumer (2 потока)	| BlockingQueue |	Простота и предсказуемость блокировок. |
| Много потоков |	ConcurrentLinkedQueue |	Высокий параллелизм за счёт CAS и мелкозернистых блокировок. |
| Требуется strong consistency |	Collections.synchronizedList() | Все изменения видны сразу, но низкий throughput. |

<img width="823" height="2296" alt="image" src="https://github.com/user-attachments/assets/2194ee0a-cddc-47a0-8b3f-76c73ccb5278" />

# Синхронизация потоков

## База матушка synchronized

* Захватывает монитор объекта (или класса для static-методов).
* Только один поток может выполнять synchronized-блок для одного монитора.

Синхронизированный метод:

	public synchronized void increment() {
    		counter++;  // потокобезопасно
	}

Синхронизированный блок (с объектом-замком):

	private Object obj = new Object(); //если у потоков разные мониторы obj - они пройдут synchronized
	public void doSomething() {
    		synchronized (obj) {  // явное указание монитора
        		counter++;
    		}
	}

Плюсы:
* Простота использования.
* Автоматическое освобождение монитора при выходе (даже если выброшено исключение).

Минусы:
* Негибкость: нельзя попробовать захватить монитор без блокировки.
* Deadlock-риск: если несколько мониторов захватываются в разном порядке.

## Lock (интерфейс) и ReentrantLock

* Явная блокировка с методами lock() / unlock().
* Позволяет гибко управлять блокировками.

	Lock lock = new ReentrantLock();

	public void increment() {
    		lock.lock();  // захватываем лок
    		try {
        		counter++;
    		} finally {
        		lock.unlock();  // освобождаем в finally!
    		}
	}
Плюсы перед synchronized:
* ✅ tryLock() — попытка захватить лок без блокировки
* ✅ Честность (fairness) — можно гарантировать FIFO-порядок потоков: Lock fairLock = new ReentrantLock(true);  // true = fair lock

Нужно не забывать unlock() (лучше использовать try-finally).

## Atomic-классы (CAS-операции)

* Используют Compare-And-Swap (CAS) — атомарные операции на уровне процессора.
* Нет блокировок (но может быть busy-waiting).

	AtomicInteger counter = new AtomicInteger(0);
	counter.incrementAndGet();  // атомарный инкремент

Другие Atomic-классы:
- AtomicLong
- AtomicBoolean
- AtomicReference (для объектов)

* ✅ Высокая производительность (нет блокировок).
* ✅ Потокобезопасность для одиночных операций.
* ❌ Сложные составные операции требуют дополнительной синхронизации

	// Потоконебезопасно:
	if (atomic.get() < 10) {
    		atomic.incrementAndGet();  // между get и increment другой поток мог изменить значение!
	}

Решение: Использовать compareAndSet() или synchronized.

## volatile (видимость переменной)

* Гарантирует, что чтение/запись переменной происходит напрямую в основную память (минуя кэш CPU).
* Решает проблему видимости, но не атомарности.
private volatile boolean flag = false;

	// Поток 1:
	flag = true;  // запись сразу видна всем потокам

	// Поток 2:
	if (flag) {   // читает актуальное значение
    		// действие
	}

**Когда использовать?**
* Для флагов (boolean, int), где важна видимость, но не нужна атомарность.
* В шаблонах типа "публикация-подписка" (publish-subscribe).

## Когда что выбирать?
* synchronized — для простых случаев (например, синхронизация метода).
* Lock — если нужны:
	* tryLock(),
	* fairness,
	* несколько Condition.
* Atomic — для одиночных атомарных операций (счётчики, флаги).
* volatile — только если видимость важнее атомарности.

# Классы-синхронизаторы.

## Semaphore (Семафор)

Ограничивает количество потоков, которые могут одновременно выполнять участок кода (как "пропускная система").

Аналогия:
Представьте мост с ограниченным числом машин. Семафор — это светофор, который пропускает только N машин одновременно.

	Semaphore semaphore = new Semaphore(3); // максимум 3 потока

	void accessResource() {
    	try {
        	semaphore.acquire();  // "занять слот" (если свободных нет — ждёт)
        	System.out.println("Поток " + Thread.currentThread().getName() + " вошёл");
        	Thread.sleep(1000);   // имитация работы
    		} catch (InterruptedException e) {
        		e.printStackTrace();
    		} finally {
        	semaphore.release();  // освободить слот
        		System.out.println("Поток " + Thread.currentThread().getName() + " вышел");
    		}
	}
 
## CountDownLatch (Защёлка с обратным отсчётом)

Позволяет **одному или нескольким потокам ждать**, пока другие потоки **не завершат работу**.

Аналогия:
Стартовая решётка в гонке:
1. Гонщики (потоки) ждут, когда судья (главный поток) опустит флаг (countDown).
2. Как только счётчик достигает 0 — все стартуют.

Пример:

	CountDownLatch latch = new CountDownLatch(3); // отсчёт с 3

	// Потоки-работники
	Runnable worker = () -> {
    		System.out.println("Поток " + Thread.currentThread().getName() + " начал работу");
    		latch.countDown();  // уменьшаем счётчик
	};

	// Запускаем workers
	new Thread(worker).start();
	new Thread(worker).start();
	new Thread(worker).start();

	// Главный поток ждёт
	latch.await();  // блокируется, пока счётчик не станет 0
	System.out.println("Все потоки завершили работу!");

**Когда использовать?**
Ожидание инициализации сервисов перед стартом приложения.

Тестирование многопоточного кода (дождаться завершения всех потоков).

## CyclicBarrier (Циклический барьер)

**Что делает?**
Заставляет потоки ждать друг друга у барьера. Когда все собрались — выполняют действие и продолжают.

**Аналогия:**
Группа туристов ждёт у горы, пока все не соберутся, и только тогда начинают восхождение.

	CyclicBarrier barrier = new CyclicBarrier(3, () -> {
    		System.out.println("Все потоки достигли барьера!");
	});

	Runnable task = () -> {
    		System.out.println("Поток " + Thread.currentThread().getName() + " начал");
    		try {
        		Thread.sleep((long) (Math.random() * 2000));
        		barrier.await();  // ждём остальных
        		System.out.println("Поток " + Thread.currentThread().getName() + " продолжил");
    		} catch (Exception e) {
        		e.printStackTrace();
    		}
	};

	new Thread(task).start();
	new Thread(task).start();
	new Thread(task).start();

Отличие от CountDownLatch:
* CountDownLatch — одноразовый, CyclicBarrier — можно использовать многократно.
* В CyclicBarrier можно задать действие при достижении барьера (например, логирование).

Когда использовать?
* Параллельная обработка данных с синхронизацией (например, MapReduce).
* Имитация "раундов" в многопоточной игре.

## Exchanger (Обменник)

Что делает?
Позволяет **двум потокам обмениваться данными** в определённой точке.

	Exchanger<String> exchanger = new Exchanger<>();

	Runnable producer = () -> {
    		try {
        		String data = "Данные от производителя";
        		System.out.println("Производитель отправил: " + data);
        		String response = exchanger.exchange(data);  // ждём потребителя
        		System.out.println("Производитель получил: " + response);
    		} catch (InterruptedException e) {
		        e.printStackTrace();
    		}
	};

	Runnable consumer = () -> {
    	try {
        	String data = "Данные от потребителя";
        	System.out.println("Потребитель отправил: " + data);
        	String response = exchanger.exchange(data);  // ждём производителя
        	System.out.println("Потребитель получил: " + response);
    		} catch (InterruptedException e) {
        		e.printStackTrace();
    		}
	};

	new Thread(producer).start();
	new Thread(consumer).start();

 **Вывод:**

	Производитель отправил: Данные от производителя  
	Потребитель отправил: Данные от потребителя  
	Производитель получил: Данные от потребителя  
	Потребитель получил: Данные от производителя  

 ## Phaser (Фазировщик)

Улучшенная версия CyclicBarrier с поддержкой динамического числа участников и многофазной синхронизации.

	Phaser phaser = new Phaser(3); // 3 участника

	Runnable task = () -> {
    		System.out.println("Поток " + Thread.currentThread().getName() + " в фазе " + phaser.getPhase());
    		phaser.arriveAndAwaitAdvance();  // ждём остальных

    		System.out.println("Поток " + Thread.currentThread().getName() + " в фазе " + phaser.getPhase());
    		phaser.arriveAndAwaitAdvance();  // ждём снова
	};

	new Thread(task).start();
	new Thread(task).start();
	new Thread(task).start();

**Что спросят на собеседовании?**
* Чем CountDownLatch отличается от CyclicBarrier?
	* CountDownLatch — одноразовый, CyclicBarrier — циклический.
	* В CyclicBarrier потоки ждут друг друга, в CountDownLatch — главный поток ждёт остальных.
* Зачем нужен Semaphore?
	* Чтобы ограничить число потоков, работающих с ресурсом одновременно.
* Как сделать, чтобы 3 потока стартовали одновременно?
	* Использовать CyclicBarrier(3).

Вывод
Semaphore — для ограничения доступа.

CountDownLatch — чтобы дождаться завершения потоков.

CyclicBarrier — для синхронизации в точке.

Exchanger/Phaser — для более сложных сценариев.
