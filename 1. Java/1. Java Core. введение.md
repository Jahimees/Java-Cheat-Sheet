# Введение

## Базовые понятия
**Java** - это *объектно-ориентированный*, *платформенно-независимый* язык программирования,
используемый для разработки информационных систем, работающих в сети Internet и вычислительная платформа.

**Application program interface** (API), или library (библиотека), содержит предопределенный классы и
интерфейсы, используемые для разработки Java-программ.

**Java Standart Edition** Java SE - разработка самостоятельных приложений на Java
**Java Enterprise Edition** Java EE - разработка приложений на стороне сервера, таких как сервлеты, JSP.
**Java micro Edition** Java ME - разработка приложений под мобильные устройства

## Jvm, Jre, Jdk
**JVM** - Java Virtual Machine, виртуальная машина Java, часть ПО Java, интерпретирующая байт-код, описываемый в класс-файлах.

**JRE** - это Java Runtime Environment, среда выполнения Java, предназначена только для запуска Java приложений, а поэтому содержит
лишь реализацию виртуальной машины и набор стандартных библиотек.

**JDK** - это Java Development Kit, средств разработчика Java, включащающее в себя набор утилит, стандартные библиотеки с их
исходным кодом и набор демонстрационных примеров. 
Утилиты включают в себя:
* java - реализация JVM
* javac - компилятор java
* jar - архиватор формата JAR
* javadoc - утилита для автоматической генерации документации

## Использование памяти
Объекты - расположены в **динамической памяти** (heap) и доступны по **ссылкам**, которые
расположены в **стеке (non-heap, stack)**.

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/088aa06d-b840-4d03-9a06-537cecc32348)

**Память**, выделяемая для ссылок, *управляется автоматически*, как и память для
примитивных типов. Память для каждого объекта при помощи этой операции **new**.

*Программа не освобождает выделенную память*, это делает JVM. Автоматическое
освобождение памяти, занимаемой уже ненужными (неиспользуемыми) объектами
выполняется в JVM программным механизмом, который называется ***сборщиком мусора*** (garbage collector).

***Подробнее про сборку мусора тут: https://clck.ru/3Asix2***

## Жизненный цикл программ на Java
![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/89163040-cf23-4bf8-a322-a9e7376d8991)

## Пакеты

**Пакеты** – это контейнеры классов, которые используются для разделения
пространства имен классов.
Пакет в Java создается включением в текст программы первым оператором
ключевого слова package.

    package имя_пакета;
    package имя_пакета.имя_подпакета.имя_подпакета;

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/3147e250-8dac-4181-bfbf-7f609b59e3ca)

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/4f02583e-0a22-4a9e-855a-e91533683d35)

## Модификаторы доступа

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/b9513e20-27ac-4428-928f-aefbfef52824)
Слева направо от более защищенных к менее.
* private - самый строгий модификатор. Доступ может быть только внутри класса (к полю или методу)
* package (friendly) - доступ может быть получен в одном и том же пакете.
* protected - доступ может быть получен в одном и том же пакете, а также в классе-наследнике.
* public - доступ открыт всем

        package one;
  
        public class A {
          private int a = 1;
          int b = 2;
          protected int c = 3;
          public int d = 4;
        }

        ________________________________________________

        package one;

        public class B {
            pubic doSomething() {
                A a = new A();
                System.out.println(a); //нельзя из-за private
                System.out.println(b); //можно, так как оба находятся в одном пакете - one
                System.out.println(c); //Можно, так как находятся в одном пакете - one
                System.out.pringlt(d); //Можно, так как класс открыт всем
            }
        }

        ________________________________________________

        package two;

        public class C extends A {
                pubic doSomething() {
                A a = new A();
                System.out.println(a); //нельзя из-за private
                System.out.println(b); //нельзя, так как находятся в разных пакетах.
                System.out.println(c); //Можно, так как находятся класс наследуется от класса A
                System.out.pringlt(d); //Можно, так как класс открыт всем
            }
        }

        
# Типы данных, переменные

## Примитивные типы

Язык Java является объектно-ориентированным, но существуют типы данных (простые/примитивные), не являющиеся объектами:
 * целые: **int, byte, short, long**;
 * числа с плавающей точкой: **float, double**;
 * символы: **char**;
 * логические: **boolean**.
Синтаксис Java позволяет создавать свои типы, получившие название ссылочных

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/43f01c8c-d3d6-4fb1-ba8e-954877d83fa8)

### Особенности
* Размер примитивных типов одинаков для всех платформ; за счет этого становится возможной переносимость кода
* Размер boolean неопределен. Указано, что он может принимать значения true или false.
* Преобразования между типом boolean и другими типами не существует.

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/800b7a1c-ce02-46d6-9db2-ea55294a448c)

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/14ae73e0-766c-4650-9505-af8eae6155b1)

### Значения по умолчанию
![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/5d6ba114-1c07-480c-9926-0f20eb7f74d5)

## Переменные
Характеристики переменных:
 * основное место для хранения данных;
 * должны быть явно объявлены;
 * каждая переменная имеет тип, идентификатор и область видимости;
 * определяются для класса, для экземпляра и внутри метода. (имеется ввиду статические, нестатические и локальные)
Объявление переменных:
 * может быть объявлена в любом месте блока кода;
 * должна быть объявлена перед использованием;
 * обычно переменные объявляются в начале блока (или класса);
 * область видимости определяется блоком;
 * необходимо инициализировать переменные перед использованием;
 * переменные простых типов инициализируются автоматически.

 _В именах переменных не могут использоваться символы арифметических и
логических операторов, а также символ ‘#’._

Применение символов ‘$’ и ‘_’ допустимо, в том числе и в первой позиции имени.

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/e8e68c84-1053-4f98-be7f-175a9da9426d)


Кроме ключевых слов, в Java существуют три литерала: **null, true, false**,не относящиеся
к ключевым и зарезервированным словам. А также дополнительные зарезервированные
слова: **const, goto.**

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/6e7d9cb8-c476-4114-9f46-8afb7652f87e)

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/76dc439e-6091-4943-855b-113f700606fc)


![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/fdbf0b74-70c8-494a-8d48-8a93137cde6c)

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/5c2d7168-33d8-433c-b7e3-b8cf35d596cd)

## Преобразование (приведение) примитивных типов

Java запрещает смешивать в выражениях величины разных типов, однако при числовых операциях такое часто бывает необходимо.
Различают:
 *повышающее (разрешенное, неявное)* преобразование;
 *понижающее (явное)* приведение типа.
_Расширяющее (повышающее) преобразование_. Результирующий тип имеет больший
диапазон значений, чем исходный тип.

    int x = 200;
    long y = (long)x;
    long z = x;
    long value1 = (long)200; //необязательно, т.к. компилятор делает это автоматически

_Неявное (повышающее) преобразование_ осуществляется автоматически, даже в случае потери данных.

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/7695014f-07d9-4daf-82ce-fceb5cc012c1)

Серыми стрелками обозначены преобразования, при которых может произойти потеря
точности.
    
_Сужающее (понижающее) преобразование_. Результирующий тип имеет меньший
диапазон значений, чем исходный тип.
    long value2 = 1000L;
    int value3 = (int)value2; //обязательно

При вычислении выражения (a @ b) аргументы a и b преобразовываются в числа, имеющие одинаковый тип:
 * если одно из числе double, то в double;
 * иначе, если одно из чисел float, то в float;
 * иначе, если одно из чисел long, то в long;
 * иначе оба числа преобразуются в int.

Арифметическое выражение над byte, short или char имеет тип int, поэтому для присвоения результата обратно в byte, short или char понадобится явное приведение типа.

### Особенности приведения вещественных чисел

Слишком _большое дробное число_ при приведении к целому превращается в **Integer.MAX_VALUE** или **Integer.MIN_VALUE**
Слишком большой _double_ при приведении к _float_ превращается в **Float.POSITIVE_INFINITY** или **Float.NEGATIVE_INFINITY**

## Классы-оболочки

Кроме базовых типов данных широко используются соответствующие классы
(wrapper классы):
 * Boolean, Character, Integer, Byte, Short, Long, Float, Double.
 * Объекты этих классов могут хранить те же значения, что и соответствующие имбазовые типы.
 * Объекты этих классов представляют ссылки на участки динамической памяти, в которой хранятся их значения, и являются классами оболочками для значений базовых типов.
 * Объекты этих классов являются константными.

Классы-оболочки (кроме Boolean и Character) являются наследниками абстрактного класса Number и реализуют интерфейс Comparable, представляющий собой интерфейс для работы со всеми скалярными типами.

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/4b5d39a8-5540-4499-9ce6-cb58d287defa)

Класс **_Character_** не наследуется от **_Number_**, так как ему нет необходимости поддерживать интерфейс классов, предназначенных для хранения результатов арифметических операций.
Класс **_Character_** имеет целый ряд специфических методов для обработки символьной информации.
У этого класса, в отличие от других классов оболочек, _не существует конструктора с параметром типа String.

## Big-классы

Java включает два класса для работы с высокоточной арифметикой:
**BigInteger и BigDecimal,**

которые поддерживают целые числа и числа с фиксированной точкой произвольной точности.

      import java.math.BigInteger;
      public class BigNumbers {
        public static void main(String[] args) {
          BigInteger numI1, numI2, bigNumI;
          numI1 = BigInteger.valueOf(1_000_000_000_000L);
          numI2 = numI1.multiply(numI1);
          System.out.println(numI2);
          
          numI2 = numI1.multiply(numI1).multiply(numI1);
          System.out.println(numI2);
          
          numI2 = numI1.multiply(numI1).multiply(numI1).multiply(numI1);
          System.out.println(numI2);
          
          numI2 = numI1.multiply(numI1).multiply(numI1)
               .multiply(numI1).multiply(numI1);

          System.out.println(numI2);
          numI2 = numI1.multiply(numI1).multiply(numI1).multiply(numI1)
               .multiply(numI1).multiply(numI1);
           
          System.out.println(numI2);
          }
      }

## Автоупаковка (распаковка)

В версии **_5.0_** введен процесс автоматической инкапсуляции данных базовых типов в соответствующие объекты оболочки и обратно (_автоупаковка_). При этом нет необходимости в создании соответствующего объекта с использованием оператора new.

    Integer iob = 71;

Автораспаковка – процесс извлечения из объекта-оболочки значения базового типа. Вызовы таких методов, как intValue(), doubleValue() становятся излишними. Допускается участие объектов в арифметических операциях, однако не следует этим злоупотреблять, поскольку упаковка/распаковка является ресурсоемким процессом.

    public class AutoPack {
      public static void main(String[] args) {
        Integer j = 71; // создание объекта+упаковка
        Integer k = ++j; // распаковка+операция+упаковка

        int i = 2;
        k = i + j + k;
        System.out.println(k);
      }
    }

При автоупаковке значения базового типа возможны ситуации с появлением некорректных значений и непроверяемых ошибок.

    Number n1 = 1;
    Number n2 = 7.1;
    Number array[] = {71, 7.1, 7L};
    Integer i1 = (Integer)n1;
    Integer i2 = (Integer)n2; // runtime error
    Integer[] i3 = (Integer[])array; // runtime error


# Операторы

## Арифметические операторы

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/e2ff9822-62b5-4891-97c2-b9a2c1588b06)

## Операторы отношения

Применяются для сравнения символов, целых и вещественных чисел, а также для сравнения ссылок при работе с объектами.

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/773d0a57-7326-4558-92e8-df92e93c2f23)

## Битовые операторы

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/91add568-4043-4e54-b9a7-8ad2594252cf)

    public class URShift {
        public static void main(String[] args) {
          int i = -1; //11111111111111111111111111111111
          i >>>= 10; //00000000001111111111111111111111
          System.out.println(i);
          long l = -1;
          l >>>= 10; System.out.println(l);
          short s = -1;
          s >>>= 10; System.out.println(s);
          byte b = -1;
          b >>>= 10; System.out.println(b);
          b = -1; System.out.println(b >>> 10);
        }
    }

## Логические операторы

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/8dc03f43-c848-4d82-9d52-16bfdfa1caf8)

## Дополнительные операторы

К операторам относится также оператор определения принадлежности типу instanceof, оператор [ ] и тернарный оператор ?: (if-then-else).
Оператор instanceof возвращает значение true, если объект является экземпляром данного класса или его наследником.
    
    public class Animal {}
    public class Cat extends Animal {}
    public class MaineCoon extends Cat {}

    public class Main {
      public static void main(String[] args) {
        Cat cat = new Cat();
        System.out.println(cat instanceof Animal); //true
        System.out.println(cat instanceof MaineCoon); //false
      }
    }

## Приоритет операций

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/b124f262-d92d-4dd2-9ffd-cf86dcf79be7)

## Math и StrictMath

Для организации математических вычислений в Java существует класс Math и StrictMath.
 * java.lang.StrictMath – класс-утилита, содержащий основные математические функции. Гарантирует точную повторяемость числовых результатов вплоть до бита на разных аппаратных платформах.
 * java.lang.Math – класс-утилита, работающая быстрее чем StrictMath (на старых версиях машины), но не гарантирующая точное воспроизводство числовых результатов.
 * В версии 1.6 java.lang.Math делегирует вызовы StrictMath.

## Статический импорт

Ключевое слово import с последующим ключевым словом static используется для импорта статических полей и методов классов, в результате чего отпадает необходимость в использовании имен классов перед ними.
    import static java.lang.Math.pow;
    import static java.lang.Math.PI;
    
    public class StaticImport {
      private int i = 20;
      
      public void staticImport() {
        double x;
        x = pow(i, 2)*PI;
        System.out.println("x=" + x);
      }
    }

## Оператор If

Позволяет условное выполнение оператора или условный выбор двух операторов, выполняя один или другой, но не оба сразу.
    if (boolexp) { /*операторы*/}
    else { /*операторы*/ }//может отсутствовать

 ![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/58620090-6df5-4e5a-a050-0468929fba86)

## Циклы

Циклы выполняются, пока выполняется некоторое условие.
Цикл с предусловием (сначала проверка, потом выполнение):

    while (a>b) { //выполняем, пока a > b}

Цикл с постусловием:

    do {
     //выполняем действие 1 раз без проверки условия, далее - выполняем только после проверки
    } while (a > b);

Цикл со счетчиком:

    for (int i = 0; i < a; i++) {
      // выполняем действие в цикле пока i < a. В конце каждого шага увеличиваем i на 1
    }

Цикл перебора коллекции/массива:

    for (Type obj : objectCollection) {
      //В переменную obj поочередно заносятся переменные из коллекции objectCollection.
      //В данном блоке над ними производятся необходимые действия
    }

Циклы можно прерывать досрочно двумя способами: 
* break - немедленный выход из цикла полностью
* continue - пропускается один шаг и начинается следующий

Эти операторы можно использовать как GoTo (но не делайте так) и тогда при достижении этой строчки, программа окажется на строке с указанной меткой:

    Outer:
    for(int i=0; i < args.length ; i++) {
      // ...
      break Outer;
      // ...
    }

Цикл for следует использовать при необходимости выполнения алгоритма строго определенное количество раз. Цикл while используется в случае, когда неизвестно число итераций для достижения необходимого результата, например, поиск необходимого
значения в массиве или коллекции. Этот цикл применяется для организации бесконечных циклов в виде while(true).
* Для цикла for не рекомендуется в цикле изменять индекс цикла.
* Условие завершения цикла должно быть очевидным, чтобы цикл не «сорвался» в бесконечный цикл.
* Для индексов следует применять осмысленные имена.
* Циклы не должны быть слишком длинными. Такой цикл претендует на выделение в отдельный метод.
* Вложенность циклов не должна превышать трех.

## Оператор Switch

Оператор switch можно представить как длинный if else:

    if (a.equals("1") {}
    else if (a.equals("2") {}
    else if (a.equals("3") {}
    ...

В таких случаях целесообразнее использовать switch:

    switch(a) {
      case "1": {
        //...
        break;
      }
      case "2": {
        //...
        break;
      }
      case "3": {
        //...
        break;
      }
      default: {
      //код по умолчанию
      }
    }

# Понятие классов и объектов

## Определения

Объект – некоторая КОНКРЕТНАЯ сущность моделируемой предметной области.
Класс – шаблон или АБСТРАКЦИЯ сущности предметной области.

Исходя из картинки ниже, слева - класс, справа - его конкретные реализации - квадраты разных размеров и цветов

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/39f9a696-f5ad-4630-b6e8-689e21b2ad47)

Классом называется описание совокупности объектов с общими атрибутами, методами, отношениями и семантикой. Классы определяют структуру и поведение некоторого набора элементов предметной области, для которой разрабатывается программная модель.

Объявление класса имеет вид:

    [спецификаторы] class имя_класса
    [extends суперкласс] [implements список_интерфейсов]{
      /*определение класса*/
    }

Под спецификаторами подразумеваются различные модификаторы доступа, а также объявления класса final, static, abstract, sealed и проч.

## Sealed классы

* sealed (запечатанные) классы - классы, которые строго определяют свои классы-наследники.

    public sealed class Shape
      permits Circle, Rectangle, Square {...}

Из примера, класс Shape могут наследовать только классы Circle, Rectangle, Square
**_Разрешенные классы_** могут быть _final_, _sealed_ и _non-sealed_.

* Указание **_final_** предотвратит дальнейшее расширение этой части иерархии классов.
* **_sealed_** допускает расширение этой части иерархии за рамки первоначально определенного суперкласса, но только разрешенными им классами.
* И наконец, **_non-sealed_** открывает иерархию классов для расширения неизвестными подклассами. Однако, начиная с дочернего незапечатанного класса, суперкласс будет запечатан и недоступен для неизвестных расширений.

## Свойства и методы класса

Определение класса включает:
 * модификатор доступа;
 * ключевое слово class;
 * свойства класса;
 * конструкторы;
 * методы;
 * статические свойства;
 * статические методы.
**Объект состоит из следующих частей:**
 * тип объекта (класс, к которому он принадлежит);
 * ссылка на объект (переменная, содержащая ссылку на объект. может отсутствовать, если объект применяется "на месте")
 * состояние (переменные состояния);
 * методы (операции).
**Свойства классов:**
 * уникальные характеристики, которые необходимы при моделировании (примеры: размер, скорость, имя, возраст) предметной области
 * ОБЪЕКТЫ различаются значениями свойств
 * свойства отражают состояние объекта
**Методы классов:**
 * метод отражает ПОВЕДЕНИЕ объектов
 * выполнение методов, как правило, меняет значение свойств
 * поведение объекта может меняться в зависимости от состояния

## Методы и функции

В настоящее время грань между методами и функциями стерлась практически окончательно. Ранее разделяли методы (ничего не возвращает - в возвращаемом типе указано void) и функции (что-то возвращает).
Однако, сегодня, как бы вы не называли, никто не придерется.

Все методы определяются внутри классов.
Обявление метода имеет следующий вид:

        [спецификаторы] [static|abstract] возвращаемый_тип
            имя_метода([аргументы]) {
                /*тело метода*/
        } | ;

_Невозможно создать метод, не являющийся методом класса или объявить метод вне класса._
Спецификаторы:
   * static
   * public, protected, private
   * friendly (по умолчанию, если не указан public protected или private
   * synchronized
   * final
   * native
   * abstract
   * strictfp

## Поля, свойства

Поля отражают СОСТОЯНИЕ объекта, его характеристики и свойства
Данные – члены класса, которые называются полями или переменными класса, объявляются в классе следующим образом:

**cпецификатор** _тип_ **_имя_**;
Cпецификаторы доступа полей класса:
    * static 
    * public, private, protected 
    * final 
    * friendly 
    * transient 
    * volatile

## Конструкторы

Конструктор - метод класса, который вызывается единожды для каждого объекта при его создании (при вызове new)
* Конструктор имеет то же имя, что и класс.
* Вызывается не по имени, а только вместе с ключевым словом new при
создании экземпляра класса.
* Конструктор не возвращает значение, но может иметь параметры и быть
перегружаемым.

Создание объекта:

**_имя_класса_** _имя_переменной_ = **new** _конструктор_класса_(аргументы);

**При наследовании, вызываются все конструкторы по иерархии сверху вниз:**

        class Animal {
            public Animal() {
             sout("hello ");
            }
        }

        class Cat extends Animal {
            public Cat() {
                sout("cat");
            }
        }

_В данном случае, вызываются конструкторы Object -> Animal -> Cat. Все классы наследуются от Object по умолчанию_

## Передача параметров в методы

Представим, что есть метод:

        public void changeIt(int primary, Integer obj) {
            primary = primary + 10;
            obj = obj + 10;
        }

        //где-то в коде
        int prim = 5;
        Integer ob = new Integer(5);
        changeIt(prim, ob); //передача параметров в метод
        sout(prim); //5
        sout(ob); //15

Казалось бы, выполняются одни и те же действия, а результаты разные.
Ссылочные типы передаются в метод по ссылке (т.е. копируется ссылка на объект, но действия над объектом те же).
Примитивные типы передаются в метод по значению (копируется само значение в метод, а не ссылка. Поэтому изменения в методе не повлияют на переменную)

_При передаче в метод аргумента-ссылки можно изменить состояние объекта и оно сохранится после возвращения из метода, так как в этом случае нового объекта не создается, а создается лишь новая ссылка, указывающая на старый объект._

! **Из этого правила существует одно исключение – когда передается ссылка, указывающая на константный объект.**
 * Константный объект – это такой объект, изменить состояние которого нельзя. При попытке его изменить создается новый модифицированный объект. Примером таких объектов являются объекты класса String.
 * Если необходимо вернуть в вызывающий метод ссылку на новый константный объект, созданный в этом методе, следует указать её тип как тип возвращаемого методом значения и использовать return.

## Основы работы со строками

Создание:
String str = new String("hello");
либо
String str = "hello";
В чем разница? 
В первом случае 100% создается новый объект в так называемом "пуле строк" - место, где хранятся все литералы.
Во втором случае, java сначала проверяет существование такого литерала в пуле. если его нет - создает и возвращает ссылку на него. Если же такой литерал существует, то просто возвращает на него ссылку.

Пул литералов – это коллекция ссылок на строковые объекты.
 * Пул литералов представляет все литералы, созданные в программе.
 * Каждый раз, когда создаются строковые литералы, аналогичный литерал ищется в пуле.
 * Если создаваемый литерал уже существует в пуле, то новый экземпляр для него не создается, а возвращается адрес уже имеющегося.

* Знак + применяется для объединения двух строк.
* Если в строковом выражении применяется нестроковый аргумент, то он преобразуется к строке автоматически.

Чтобы сравнить на равенство две строки необходимо воспользоваться методом **equals()**, так как '==' сравнивает ссылки (указывают ли ссылки на один и тот же объект?), а equals у строк переопределен на сравнение значений:

        if(str1.equals(str2)){}

Длина строки определяется с помощью метода **length()**:
        
        int len = str.length();

# Java Beans (основы)

## Определения

**Java Beans** - методология, подход к проектированию классов и объектов, который нацелен на многократное использование одних и тех же объектов, уменьшение количества создания лишних объектов.
**JavaBeans** – гибкая, мощная и удобная технология разработки многократно-используемых программных компонент, называемых beans.
_C точки зрения ООП, компонент JavaBean_ – это классический самодостаточный объект, который, будучи написан один раз, может быть многократно использован при построении новых апплетов, сервлетов, полноценных приложений, а также других компонент JavaBean.
Отличие от других технологий заключается в том, что компонент JavaBean строится по определенным правилам, с использованием в некоторых ситуациях строго регламентированных интерфейсов и базовых классов.
Java bean – многократно используемая компонента, состоящая из **свойств** (properties), **методов** (methods).

**Свойства компоненты Bean** – это дискретные, именованные атрибуты соответствующего объекта, которые могут оказывать влияние на режим его функционирования (обычные поля).
В отличие от атрибутов обычного класса, свойства компоненты Bean должны задаваться вполне определенным образом: _нежелательно объявлять_ какой-либо атрибут компоненты Bean как _public_. Наоборот, его следует декларировать как **private**, а сам класс дополнить двумя методами **set** и **get**.

    import java.awt.Color;
      public class BeanExample {
        private Color color;
        
        public void setColor(Color newColor) {
          color = newColor;
        }
        
        public Color getColor() {
          return color;
        }
    }

## Свойства Bean, массивы

Согласно спецификации Bean, методы set и get необходимо использовать не только для атрибутов простого типа, таких как int или String, но и в более сложных ситуациях, например для внутренних массивов String[].

    public class BeanArrayExample {
      private double data[];
      public double getData(int index) {
        return data[index];
      }
      public void setData(int index, double value) {
        data[index] = value;
      }
      public double[] getData() {
        return data;
      }
      
      public void setData(double[] values) {
        data = new double[values.length];
        System.arraycopy(values, 0, data, 0, values.length);
      }
    }

## Свойства Bean, boolean

Атрибуту типа boolean в классе Bean должны соответствовать методы is и set.

    public class BeanBoolExample {
      private boolean ready;
      
      public void setReady(boolean newStatus) {
        ready = newStatus;
      }
      
      public boolean isReady() {
        return ready;
      }
    }

# Массивы

## Определения

Для хранения нескольких однотипных значений используется ссылочный тип – массив.
Массивы элементов базовых типов состоят из значений, проиндексированных начиная с нуля.
Все массивы в языке Java являются динамическими, поэтому для создания массива требуется выделение памяти с помощью оператора **new** или инициализации.

      int[] price = new int[10];

Значения элементов неинициализированных массивов, для которых выделена память, устанавливается в **нуль**.
Многомерных массивов в Java не существует, но можно объявлять массивы массивов. 

      int[][] twoDimentionalArray = new Array[8][8]

Для задания начальных значений массивов существует специальная форма инициализатора.

      int[] rooms = new int[] { 1, 2, 3 };

Массивы объектов в действительности представляют собой массивы ссылок, проинициализированных по умолчанию значением null.
Все массивы хранятся в куче (heap), одной из подобластей памяти, выделенной системой для работы виртуальной машины.
Определить общий объем памяти и объем свободной памяти, можно с помощью методов totalMemory() и freeMemory() класса Runtime.

Имена массивов являются ссылками. Для объявления ссылки на массив можно записать пустые квадратные скобки после имени типа, например: int a[]. Аналогичный результат получится при записи int[] a.
      
      int myArray[];
      int mySecond[] = new int[100];
      int a[] = { 5, 10, 0, -5, 16, -2 };
      myArray = a;
      
      public class CreateArray {
        public static void main(String[] args) {
          int[] price = new int[10];
          int[] rooms = new int[] { 1, 2, 3 };
          Item[] items = new Item[10];
          Item[] undefinedItems = new Item[] { new Item(1), new Item(2), new Item(3) };
        }
      }

      class Item {
        public Item(int i) {
        }
      }

  ## Приведение типов в массивах

  Любой массив можно привести к классу Object или к массиву совместимого типа.
  
      public class ConvertArray {
        public static void main(String[] args) {
          ColoredPoint[] cpa = new ColoredPoint[10];
          Point[] pa = cpa;
          System.out.println(pa[1] == null);
          try {
            pa[0] = new Point();
          } catch (ArrayStoreException e) {
            System.out.println(e);
          }
        }
      }
      
      class Point {
        int x, y;
      }
      
      class ColoredPoint extends Point {
        int color;
      }

  ## Ошибки времени выполнения

Обращение к несуществующему индексу массива отслеживается виртуальной машиной во время исполнения кода:

    public class ArrayIndexError {
      public static void main(String[] args) {
        int array[] = new int[] { 1, 2, 3 };
        System.out.println(array[3]);
      }
    }
    
Попытка поместить в массив неподходящий элемент пресекается виртуальной машиной:
    public class ArrayTypeError {
      public static void main(String[] args) {
        Object x[] = new String[3];
        // попытка поместить в массив содержимое
        // несоответствующего типа
        x[0] = new Integer(0);
      }
    }

# Преобразование чисел

Перевести строковое значение в величину типа _int_ или _double_ можно с помощью методов _parseInt()_ и _parseDouble()_ классов _Integer_ и _Double_.
Обратное преобразование возможно при использовании метода _valueOf_() класса _String_. Кроме того, любое значение можно преобразовать в строку путем конкатенации его (+) с пустой строкой (“”).

    public class StrToNum {
      public static void main(String[] args) {
        String strInt = "123";
        String strDouble= "123.24";
        
        int x;
        double y;
        double z;
        
        x = Integer.parseInt(strInt); //в int
        y = Double.parseDouble(strDouble); //в double
        System.out.println(x+y);
        
        strInt = String.valueOf(x); //обратно в строку
        strDouble = String.valueOf(y); //обратно в строку
        System.out.println("strInt=" + strInt);
        System.out.println("strDouble=" + strDouble);
        
        String str;
        str = "num=" + 345;
        System.out.println(str); //конкатенация. Автоматически 345 станет частью строки str.
      }
    }

Для преобразования целого числа в десятичную, двоичную, шестнадцатеричную и восьмеричную строки используются методы toString(), toBinaryString(), toHexString() и toOctalString().

  public class StrToNumberSystem {
    public static void main(String[] args) {
      System.out.println(Integer.toString(267));
      System.out.println(Integer.toBinaryString(267));
      System.out.println(Integer.toHexString(267));
      System.out.println(Integer.toOctalString(267));
    }
  }


# Принципы ООП

Всюду разнятся принципы: где-то их 4 и добавляют абстракцию, где-то добавляют механизм позднего связывания. Однако 3 непоколебимых принципа должен знать каждый:
* Инкапсуляция
* Наследование
* Полиморфизм
*  + Абстракция
*  + Позднее связывание

## Инкапсуляция 

В теории:
_Инкапсуляция (encapsulation)_ - это механизм, который объединяет данные и код, манипулирующий этими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования.
На практике (чаще всего):
* все поля private (кроме констант). Могут устанавливаться другие модификаторы, но крайне редко;
* к полям предоставляется доступ через get (геттеры - для получения значения) и set (сеттеры - для установки значения) методы:

      public class SimpleExample {
          private int id;

          //Геттер не имеет входных параметров, возвращает значение поля
          public int getId() {
            return id;
          }

          //Сеттер имеет возвращаемый тип - void. Принимаемый - соответствует типу поля
          public void setId(int id) {
            this.id = id;
            //также тут можно сделать проверку перед установкой значения. Но чаще всего перед установкой значения его проверяют до вызова set метода.
            //Все зависит от ситуации. Но не рекомендуется делать проверку в сеттере, поскольку пользователь (как ему кажется) присваивает одно значение, а затем - получает другое
          }
      }

* **set** или **get** методов _может и не быть_, если это обусловлено. Например. Если переменная должна изменяться только внутри класса, то сеттера быть не должно.
* Учитывайте, что _геттер_, который возвращает ссылочный тип, _возвращает копию ССЫЛКИ_, а не _ОБЪЕКТА_ -> **пользователь через get метод может изменять объект**. Такое поведение, зачастую, _неприемлемо_. В идеале возвращать клон объекта (**переопределенный метод clone()**)

## Наследование

Наследование (inheritance) - это процесс, посредством которого, один объект может наследовать свойства другого объекта и добавлять к ним черты, характерные только для него.
Наследование бывает двух видов:
* одиночное - когда каждый класс имеет одного и только одного предка;
* множественное - когда каждый класс может иметь любое количество предков.

Наследуются: 
* методы (если позволяет модификатор доступа)
* поля (если позволяет модификатор доступа).

Например private методы или поля не наследуются. Однако, если у поля есть публичные геттеры или сеттеры, до доступ к переменной можно получить.

Наследование от класса (можно унаследоваться только от 1 класса):

    public class A extends B {...}

Реализация интерфейсов (интерфейсов может быть сколь угодно множество):

    public class A implements B {...} 

где B - интерфейс

**!Важный момент!**
Если класс-наследник определяет свои собственные методы, то при создании ссылки типа родителя, методов наследника видно не будет!!
Есть два класса:

    public class Parent {
      private int id;

      //getter
      //setter
    }

    public class Child extends Parent {
        public void printId() {
          sout(getId());
        }
    }

    psvm() {
      Child child = new Child();
      child.printId(); //сработает

      Parent parentChild = new Child();
      parentChild.printId(); //ошибка компилляции. Необходимо приведение
    }

Решение: определить Parent интерфейсом либо абстрактным классом и определить метод printId(), чтобы он переопределялся классом-наследником (см. полиморфизм)

    public abstract class Parent {
        private int id;

        //getter
        //setter

        public abstract void printId();
    }

    public class Child extends Parent {

        @Override
        public void printId() {
          sout(getId());
        }
    }

    psvm() {
      Child child = new Child();
      child.printId(); //сработает

      Parent parentChild = new Child();
      parentChild.printId(); //теперь тоже сработает
    }

Если поле приватно, то у наследника не будет прямого доступа к этому полю, однако, если будут существовать геттеры и сеттеры, то поле может быть доступно и использованно посредством этих методов:

            public class Parent {

                private int id;

                //геттеры и сеттеры
                public void setId(id) {
                      this.id = id;
                }

                public int getId() {
                      return this.id;
                }
            }

            public class Child extends Parent {

                  public void someMethod() {
                        this.id; //недоступно
                        setId(5); //можно
                        getId(); //можно
                  }
            }

## Полиморфизм

**Полиморфизм (polymorphism)** - это свойство, которое позволяет одно и то же имя использовать для решения двух или более схожих, но технически разных задач.

**Полиморфизм** - один интерфейс, множество реализаций.

В ООП **полиморфизмом** чаще всего называют способность классов с одинаковой спецификацией (интерфейсом) определять различную реализацию, что, в свою очередь, позволяет клиентскому коду абстрагироваться от этой самой реализации и работать с классом, исходя из его спецификации. Например, ваш метод может ожидать получить на входе объект типа UserInterface, при этом не зная, с каким конкретным подтипом типа UserInterface он будет работать.

Пример:

      public interface Parent {

        void printInfo();
      }

      public class Child1 {
        @Override
        public void printInfo() {
         //одна реализация
        }
      }

      public class Child2 {
        @Override
        public void printInfo() {
          //вторая реализация
        }
      }

      public class SomeClass {

        //Метод не знает, что именно он использует - Child1 или Child2
        public void someMethod(Parent parent) {
          parent.printInfo();
        }
      }

## Динамическое связывание

**Динамическое связывание (dynamic binding)** – связывание, при котором ассоциация между ссылкой(именем) и классом не устанавливается, пока объект с заданным именем не будет создан на стадии выполнения программы.
Мы уже разобрались, что в зависимости от ссылки на объект того или иного подкласса, Java вызовет тот или иной _переопределенный метод printInfo()_. Но откуда компилятор знает - какой из методов _printInfo()_ необходимо будет вызвать? Ответ заключается в том, что компилятор этого не знает.
Присоединение вызова метода к телу метода называется связыванием. 

Если связывание производится перед запуском программы (на этапе компиляции или компоновки), оно называется _ранним_ (_early_) или _статическим_ (_static_) связыванием (_binding_).

Неоднозначность в работе метода _someMethod()_ связана именно с ранним связыванием: компилятор не может знать заранее, какой вариант метода _printInfo_() нужно будет вызвать, когда у него есть только ссылка на объект реализацию интерфейса _Parent_ (неизвестно какую).

Данная проблема решается благодаря позднему связыванию, то есть связыванию, проводимому во время выполнения программы, в зависимости от типа объекта. _Позднее (late) связывание (binding)_ также называют _динамическим (dynamic)_ или связыванием на этапе выполнения программы (_runtime binding_).
В реализации Java существует механизм для фактического определения типа объекта во время работы программы для вызова подходящего метода. Иначе говоря, компилятор не знает тип объекта, но механизм вызова метода определяет фактический тип объекта и вызывает соответствующее тело метода.
Для **всех методов** Java **используется механизм позднего связывания**, если только метод не был объявлен как **final** (приватные методы являются **final** по умолчанию).

Итак, подведем итоги:
* статическое связывание в Java происходит на этапе компиляции, тогда как динамическое связывание происходит во время выполнения программы (в runtime);
* для private, final и static методов, а также для полей используется статическое связывание, тогда как для остальных методов (такие методы в некоторых языках программированию называются виртуальными (virtual)) используется динамическое связывание;
* в статическом связывании используется тип ссылки, тогда как в динамическом связывании используется фактический тип объекта;
* перегруженные методы используют статическое связывание, тогда как переопределенные методы используют динамическое связывание.

# Простейшие классы и объекты

## Класс

Классом называется описание совокупности объектов с общими атрибутами, методами, отношениями и семантикой.
Классы определяют структуру и поведение некоторого набора элементов предметной области, для которой разрабатывается программная модель.

Класс: Дом
Объект: Дом: двухэтажный, красный, 30 окон, 3 подъезда

Каждый класс имеет свое имя, отличающее его от других классов, и относится к определенному пакету.
Имя класса в пакете должно быть уникальным.
Объявление класса имеет вид:

    [спецификаторы] class имя_класса [extends суперкласс] [implements список_интерфейсов]{
      /*определение класса*/
    }

    public class Point2D {
      private int x;
      private int y;
      public void setX(int _x) {
        x = _x;
      }
    
      public void setY(int _y) {
        y = _y;
      }
    
      public int getX() {
        return x;
      }
    
      public int getY() {
        return y;
      }
    }

Объект - конкретная реализация класса в виде сущности с четко определенными параметрами (вес - 10кг, цвет - зеленый), которые отражают её состояние, а также может обладать каким-то поведением.
Объект ООП - это совокупность переменных состояния и связанных с ними методов(операций). Эти методы определяют как объект взаимодействует с окружающим миром.

## Спецификаторы класса

Спецификатор класса может быть:
* public (класс доступен объектам данного пакета и вне пакета).
* final (класс не может иметь подклассов).
* abstract (класс содержит абстрактные методы, объекты такого класса могут создавать только подклассы).
По умолчанию спецификатор доступа устанавливается в friendly (класс доступен в данном пакете). Данное слово при объявлении вообще не используется и не является ключевым словом языка.

## Методы

Все функции определяются внутри классов и называются методами.
Объявление метода имеет вид:
   
    [спецификаторы] [static|abstract] возвращаемый_тип имя_метода([аргументы]) {
      /*тело метода*/
    } | ;

Невозможно создать метод, не являющийся методом класса или объявить метод вне класса.
Cпецификаторы доступа методов:

* static public
* final private
* protected abstract
* friendly native
* strictfp synchronized

Вызов метода:

        public class Test {
            public void someTest() {
                sout("hello");
            }
        }
        
        psvm() {
            Test test = new Test();
            test.someTest(); //Вызов метода
        }

## Поля

Данные – члены класса, которые называются полями или переменными класса, объявляются в классе следующим образом:

    **cпецификатор** _тип_ **_имя_**;

Cпецификаторы доступа полей класса:
* static public
* final private
* protected friendly
* transient volatile

## Конструкторы

Конструктор – это метод, который автоматически вызывается при создании объекта класса и выполняет действия только по инициализации объекта;
* Конструктор имеет то же имя, что и класс;
* Вызывается не по имени, а только вместе с ключевым словом new при создании экземпляра класса;
* Конструктор не возвращает значение, но может иметь параметры и быть перегружаемым.

        public class Book {
            private int price;
  
            public Book() {
                price = 0;
            }
  
            public Book(int price){
                setPrice(price);
            }

            public void setPrice(int price){
                this.price = price;
            }

            public int getPrice(){
                return price;
            }
        }

При наследовании, конструкторы вызываются поочередно, начиная с родителя до класса, объект которого создается. Если быть точным, то первым вызывается конструктор Object.

        public class Parent {
            public Parent() {
                //sout("Parent")
            }
        }

        public class Child1 extends Parent {
            public Child1() {
                //sout("Child1")
            }
        }

        public class Child2 extends Parent {
            public Child2() {
                //sout("Child2")
            }
        }

        psvm() {
            Parent p = new Child2();
            Вызов конструкторов: Object -> Parent -> Child1 -> Child2
        }
        
# Классы и объекты

## Перегрузка методов
**Overload (перегрузка метода)** – определение методов с одинаковым наименованием но различной сигнатурой. Фактически, такие методы – это совершенно разные методы с совпадающим наименованием. Сигнатура метода определяется наименованием метода, а также числом и типом параметров метода.

    public class DatePrinter {
      
      public int printDate(String s) {
        System.out.printf("String s=", s);
        return 1;
      }

      public void printDate(int day, int month, int year) {
        System.out.println("int day=" + day);
      }
      
      public static void printDate(Date d) {
        System.out.printf("Date d=", d);
      }
    }

* Перегрузка реализует «раннее связывание».
* Статические методы могут перегружаться нестатическими и наоборот – без ограничений.
* При непосредственной передаче объекта в метод выбор производится в зависимости от типа ссылки на этапе компиляции.

# Композиция и агрегация

**Ассоциация** — это самый общий вид связи между двумя классами, при которой один класс как-то связан с другим.
**Композиция и агрегация** — это два вида связей между классами, которые описывают, как один объект может содержать другой.

## Агрегация (слабая связь)

Объект-часть **может** существовать без объекта-целого.
Пример: Автомобиль и Двигатель. Если автомобиль уничтожить, двигатель может остаться (например, его переставят в другой автомобиль).

    class Engine {
        // код двигателя
    }

    class Car {
        private Engine engine;  // агрегация
    
        public Car(Engine engine) {
            this.engine = engine;  // двигатель пришел извне
        }
    }
    
## Композиция (сильная связь)

Объект-часть **не может** существовать без объекта-целого.
Пример: Дом и Комната. Если дом разрушить, комнаты тоже перестанут существовать.

    class Room {
        // код комнаты
    }

    class House {
        private Room room;  // композиция
    
        public House() {
            this.room = new Room();  // комната создается внутри дома
        }
    }
    
Главные отличия
Агрегация: Слабая связь, Объект-часть живёт отдельно, Передается извне (new Car(engine))
Композиция: Сильная связь, Объект-часть умирает с целым, Создается внутри (new Room())

**Когда что использовать?**
**Агрегация** — если объект может принадлежать разным владельцам (например, студент и университет: студент может перейти в другой вуз).
**Композиция** — если объект существует только в контексте другого (например, заказ и позиции заказа: удалили заказ — позиции тоже удаляются).
