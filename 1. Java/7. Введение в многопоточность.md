_Источники_
_https://habr.com/ru/articles/745910/_
_https://javarush.com/groups/posts/1878-mnogopotochnostjh-v-java_
_https://habr.com/ru/articles/164487/_

## Введение. Основные понятия

**Процесс** - это экземпляр выполняющейся программы, простыми словами при запуске любой программы на вашем компьютере, вы порождаете процесс. Он имеет свое собственное адресное пространство памяти и один или несколько потоков.

Process (процесс) – выполняющийся экземпляр программы, которому Операционная Система (ОС) выделила память, процессорное время/ядра и прочие ресурсы. Важно, что память выделяется отдельно, адресные пространства различных процессов недоступны друг другу. Если процессам необходимо обмениваться данными, они могут это сделать с помощью файлов, каналов и иных способов межпроцессного взаимодействия.

**Поток** - это последовательность инструкций, выполняющаяся внутри процесса. Потоки делят адресное пространство памяти процесса, что позволяет им работать параллельно.

Java Thread (поток). Иногда, чтобы не путать с другими классами Java – Stream и подобными, потоки Java часто переводят как нить. Они используют выделенные для процесса ресурсы и являются способом выполнения процесса. Главный поток выполняет метод main и завершается. При выполнении процесса могут порождаться дополнительные потоки (дочерние). Потоки одного процесса могут между собой обмениваться данными. Многопоточность Java требует учитывать синхронизацию данных, не забывайте об этом.

В Java процесс завершается тогда, когда закончил работу последний его поток. Для фоновых задач поток можно запустить как демон (daemon), отличие которого от обычного в том, что они будут принудительно завершены при окончании работы всех не-daemon потоков процесса. 

**Внутри** ПРОЦЕССА может быть множество ПОТОКОВ.

На самом деле потоки не работают параллельно друг другу. Программа выделяет потокам определенное процессорное время, в которое поток будет работать. То есть, потоки работают поочередно, просто меняются между собой очень-очень быстро.

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/cc405d93-6e93-4079-9897-2f2d5254f3e2)


## Состояния потока

Каждый поток пребывает в одном из следующих состояний (state):
* Создан (New) – очередь к кадровику готовится, люди организуются.
* Запущен (Runnable) – наша очередь выстроилась к кадровику и обрабатывается.
* Заблокирован (Blocked) – последний в очереди юноша пытается выкрикнуть имя, но услышав, что девушка в соседней группе начала делать это раньше него, замолчал.
* Завершён (Terminated) — вся очередь оформилась у кадровика и в ней нет необходимости.
* Ожидает(Waiting) – одна очередь ждёт сигнала от другой.

Организация потоков и их взаимодействие – это основа эффективной работы процессов.

## Базовые способы запуска потоков

Каждый процесс имеет хотя бы один выполняющийся поток. Тот поток, с которого начинается выполнение программы, называется главным. В языке Java, после создания процесса, выполнение главного потока начинается с метода main(). Затем, по мере необходимости, в заданных программистом местах, и при выполнении заданных им же условий, запускаются другие, побочные потоки.

Существует более полудюжины способов создания потоков. Для начала познакомимся базовыми.

### Способ 1

**Создать объект класса Thread, передав ему в конструкторе нечто, реализующее интерфейс Runnable. Этот интерфейс содержит метод run(), который будет выполняться в новом потоке. Поток закончит выполнение, когда завершится его метод run().**

    class SomeThing implements Runnable { //Нечто, реализующее интерфейс Runnable (содержащее метод run())
	    public void run() { //Этот метод будет выполняться в побочном потоке
		    System.out.println("Привет из побочного потока!");
    	}
    }

    public class Program { //Класс с методом main()
	    static SomeThing mThing;	//mThing - объект класса, реализующего интерфейс Runnable
	
	    public static void main(String[] args) {
		    mThing = new SomeThing();				
    
        Thread myThready = new Thread(mThing);	//Создание потока "myThready"
		    myThready.start();				//Запуск потока

		    System.out.println("Главный поток завершён...");
	    }
    }

!Для понимания того, что будет происходить дальше необходимо знать следующие понятия!
* [Анонимные классы](https://github.com/Jahimees/Java-Cheat-Sheet/blob/main/Java/%D0%A7%D0%B0%D1%81%D1%82%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B5%D0%BC%D1%8B/%D0%90%D0%BD%D0%BE%D0%BD%D0%B8%D0%BC%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B.md)
* [Лямбды](https://github.com/Jahimees/Java-Cheat-Sheet/blob/main/Java/%D0%A7%D0%B0%D1%81%D1%82%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B5%D0%BC%D1%8B/Stream%20%D0%B8%20lambda.md)

В случае, если мы знаем, что инструкции в классе SomeThing нам понадобятся всего 1 раз, то мы можем не плодить новый класс, а передать в new Thread(...) анонимный класс:

      public class Program {

          public static void main(String[] args) {
          
              Thread myThread = new Thread(new Runnable() {
              
                  public void run() {
                     System.out.println("Привет из побочного потока!");
                  }
              });

              myThread.start();
          }
      }

Далее, вспомним, что класс Runnable является функциональным, что дает нам возможность использовать лямбда:

      public class Program {

          public static void main(String[] args) {
              Thread myThread = new Thread(() -> System.out.println("Привет из побочного потока!"));
              myThread.start();
          }
      }

### Способ 2

**Создать потомка класса Thread и переопределить его метод run():**

Имеется специальный класс **Thread** в методе **run()** которого необходимо написать код, реализующий логику программы. После создания потока, можно запустить его, вызвав метод **start**().

Напишем демонстрационную программу, реализующую пример многопоточности  Java.

    class PeopleQueue extends Thread    {// Наша очередь из сотрудников, наследник класса Thread
      private String[] names;

      PeopleQueue(String... names) {// Конструктор, аргумент- массив имен сотрудников
          this.names = names;
      }

      @Override
      public void run() { // Этот метод будет вызван при старте потока
          for (int i = 0; i < names.length; i++) { // Вывод в цикле с паузой 0.5 сек очередного сотрудника
              System.out.println("Обработаны документы: " + names[i]);
              try {
                  sleep(500); // Задержка в 0.5 сек
              } catch (Exception e) {}
          }
      }
    }

    public class HR    {// Класс для демонстрации работы потока
      public static void main(String[] args) {
          // Создаем две очереди
          PeopleQueue queue1 = new PeopleQueue("Иван","Сергей","Николай","Фердинанд","Василий");
          PeopleQueue queue2 = new PeopleQueue("Мария","Людмила","Алиса","Карина","Ольга");

          System.out.println("Начали!"); // Сообщение из главного потока программы
          queue1.start();    //Запускаем одну очередь (дочерний поток)
          queue2.start(); //Запускаем вторую (дочерний поток)
      }
    }

## Демонстрация работы потоков

Для демонстрации параллельной работы потоков давайте рассмотрим программу, в которой два потока спорят на предмет философского вопроса «что было раньше, яйцо или курица?». Главный поток уверен, что первой была курица, о чем он и будет сообщать каждую секунду. Второй же поток раз в секунду будет опровергать своего оппонента. Всего спор продлится 5 секунд. Победит тот поток, который последним изречет свой ответ на этот, без сомнения, животрепещущий философский вопрос. В примере используются средства, о которых пока не было сказано (isAlive() sleep() и join()). К ним даны комментарии, а более подробно они будут разобраны дальше.

    class EggVoice extends Thread {
	    @Override
	    public void run() {
		    for(int i = 0; i < 5; i++) {
			    try {
				    sleep(1000);		//Приостанавливает поток на 1 секунду
			    } catch(InterruptedException e) {}
			
			    System.out.println("яйцо!");	
		    }
		    //Слово «яйцо» сказано 5 раз
	    }
    }

    public class ChickenVoice	{ //Класс с методом main()
	    static EggVoice mAnotherOpinion;	//Побочный поток
	
	    public static void main(String[] args) {
		    mAnotherOpinion = new EggVoice();	//Создание потока
		    System.out.println("Спор начат...");
		    mAnotherOpinion.start(); 			//Запуск потока
		
		    for(int i = 0; i < 5; i++) {
			    try {
				    Thread.sleep(1000);		//Приостанавливает поток на 1 секунду
			    } catch(InterruptedException e){}
			
			    System.out.println("курица!");
		    }		
		    //Слово «курица» сказано 5 раз
      
        if (mAnotherOpinion.isAlive()) { //Если оппонент еще не сказал последнее слово
			  try {  
				    mAnotherOpinion.join();	//Подождать пока оппонент закончит высказываться.
			  } catch(InterruptedException e) {}
			
			    System.out.println("Первым появилось яйцо!");
		    } else {	//если оппонент уже закончил высказываться
					System.out.println("Первой появилась курица!");
		    }
		    System.out.println("Спор закончен!");	
	    }
    }

    Консоль (Результат заранее непредсказуем):
    Спор начат...
    курица!
    яйцо!
    яйцо!
    курица!
    яйцо!
    курица!
    яйцо!
    курица!
    яйцо!
    курица!
    Первой появилась курица!
    Спор закончен!

Как было подмечено, заранее результат непредсказуем. Это происходит из-за так называемого «асинхронного выполнения кода». Асинхронность означает то, что нельзя утверждать, что какая-либо инструкция одного потока, выполнится раньше или позже инструкции другого. Или, другими словами, параллельные потоки независимы друг от друга, за исключением тех случаев, когда программист сам описывает зависимости между потоками с помощью предусмотренных для этого средств языка.

## Завершение потоков и демоны

В Java процесс завершается тогда, когда завершается последний его поток. Даже если метод main() уже завершился, но еще выполняются порожденные им потоки, система будет ждать их завершения.

Однако это правило не относится к особому виду потоков – **демонам**. Если завершился последний обычный поток процесса, и остались только потоки-демоны, то они будут принудительно завершены и выполнение процесса закончится. Чаще всего потоки-демоны используются для выполнения фоновых задач, обслуживающих процесс в течение его жизни.

Объявить поток демоном достаточно просто — нужно перед запуском потока вызвать его метод **setDaemon(true);**
Проверить, является ли поток демоном, можно вызвав его метод boolean **isDaemon();**

### Завершение потоков

В Java существуют (существовали) средства для принудительного завершения потока. В частности метод **Thread.stop()** завершает поток незамедлительно после своего выполнения. Однако этот метод, а также **Thread.suspend()**, приостанавливающий поток, и **Thread.resume()**, продолжающий выполнение потока, были объявлены устаревшими и **их использование отныне крайне нежелательно**. _Дело в том что поток может быть «убит» во время выполнения операции, обрыв которой на полуслове оставит некоторый объект в неправильном состоянии, что приведет к появлению трудноотлавливаемой и случайным образом возникающей ошибке._

Вместо принудительного завершения потока применяется схема, в которой каждый поток сам ответственен за своё завершение. Поток может остановиться либо тогда, когда он закончит выполнение метода run(), (main() — для главного потока) либо по сигналу из другого потока. Причем как реагировать на такой сигнал — дело, опять же, самого потока. Получив его, поток может выполнить некоторые операции и завершить выполнение, а может и вовсе его проигнорировать и продолжить выполняться. Описание реакции на сигнал завершения потока лежит на плечах программиста.

Java имеет встроенный механизм оповещения потока, который называется Interruption (прерывание, вмешательство), и скоро мы его рассмотрим, но сначала посмотрите на следующую программку:

Incremenator — поток, который каждую секунду прибавляет или вычитает единицу из значения статической переменной Program.mValue. Incremenator содержит два закрытых поля – mIsIncrement и mFinish. То, какое действие выполняется, определяется булевой переменной mIsIncrement — если оно равно true, то выполняется прибавление единицы, иначе — вычитание. А завершение потока происходит, когда значение mFinish становится равно true.

    class Incremenator extends Thread {
	    //О ключевом слове volatile - чуть ниже
	    private volatile boolean mIsIncrement = true;
	    private volatile boolean mFinish = false;

	    public void changeAction() { //Меняет действие на противоположное
		    mIsIncrement = !mIsIncrement;
	    }
     
	    public void finish() { //Инициирует завершение потока
		    mFinish = true;
	    }

	    @Override
	    public void run() {
		    do {
			    if(!mFinish) { //Проверка на необходимость завершения	
				    if(mIsIncrement) {
					    Program.mValue++;	//Инкремент
            } else {
					    Program.mValue--;	//Декремент
            }
    				
				    //Вывод текущего значения переменной
				    System.out.print(Program.mValue + " ");
			    } else return;		//Завершение потока

			    try{
				    Thread.sleep(1000);		//Приостановка потока на 1 сек.
			    } catch(InterruptedException e){}
		    } while(true); 
	    }
    }

    public class Program {
	    //Переменая, которой оперирует инкременатор
	    public static int mValue = 0;
	
	    static Incremenator mInc;	//Объект побочного потока

	    public static void main(String[] args) {
		    mInc = new Incremenator();	//Создание потока
		
		    System.out.print("Значение = ");
		
		    mInc.start();	//Запуск потока
		
		    //Троекратное изменение действия инкременатора
		    //с интервалом в i*2 секунд
		    for(int i = 1; i <= 3; i++) {
			    try {
				    Thread.sleep(i*2*1000); //Ожидание в течении i*2 сек.
			    } catch(InterruptedException e){}
			
			    mInc.changeAction();	//Переключение действия
		    }
		
		    mInc.finish();	//Инициация завершения побочного потока	
	    }
    }

    Консоль:
    Значение = 1 2 1 0 -1 -2 -1 0 1 2 3 4

Взаимодействовать с потоком можно с помощью метода **changeAction**() (для смены вычитания на сложение и наоборот) и метода **finish**() (для завершения потока).

В объявлении переменных **mIsIncrement** и **mFinish** было использовано ключевое слово **_volatile_** (изменчивый, не постоянный). _Его необходимо использовать для переменных, которые используются разными потоками_. Это связано с тем, что значение переменной, объявленной без volatile, может кэшироваться отдельно для каждого потока, и значение из этого кэша может различаться для каждого из них. 

**Объявление переменной с ключевым словом volatile отключает для неё такое кэширование и все запросы к переменной будут направляться непосредственно в память.** 

В этом примере показано, каким образом можно организовать взаимодействие между потоками. Однако есть одна проблема при таком подходе к завершению потока — Incremenator проверяет значение поля mFinish раз в секунду, поэтому может пройти до секунды времени между тем, когда будет выполнен метод finish(), и фактическим завершения потока. Было бы замечательно, если бы при получении сигнала извне, метод sleep() возвращал выполнение и поток незамедлительно начинал своё завершение. Для выполнения такого сценария существует встроенное средство оповещения потока, которое называется **Interruption** (прерывание, вмешательство).

### Interruption

Класс Thread содержит в себе скрытое булево поле, подобное полю mFinish в программе Incremenator, которое называется флагом прерывания. 
* Установить этот флаг можно вызвав метод interrupt() потока.
* Проверить же, установлен ли этот флаг, можно двумя способами.
  * Первый способ — вызвать метод bool isInterrupted() объекта потока,
  * Второй — вызвать статический метод bool Thread.interrupted().

**Первый метод** возвращает состояние флага прерывания и оставляет этот флаг нетронутым. 

**Второй метод** возвращает состояние флага и сбрасывает его. 

**Заметьте что Thread.interrupted()** — статический метод класса Thread, и его вызов возвращает значение флага прерывания того потока, из которого он был вызван. Поэтому этот метод вызывается только изнутри потока и позволяет потоку проверить своё состояние прерывания.

Итак, вернемся к нашей программе. Механизм прерывания позволит нам решить проблему с засыпанием потока. У методов, приостанавливающих выполнение потока, таких как **sleep(), wait() и join() **есть одна особенность — если во время их выполнения будет вызван метод _interrupt_() этого потока, они, не дожидаясь конца времени ожидания, **сгенерируют исключение InterruptedException**.

Переделаем программу Incremenator – теперь вместо завершения потока с помощью метода finish() будем использовать стандартный метод interrupt(). А вместо проверки флага mFinish будем вызывать метод bool Thread.interrupted();

Так будет выглядеть класс Incremenator после добавления поддержки прерываний:

    class Incremenator extends Thread {
	    private volatile boolean mIsIncrement = true;

	    public void changeAction() { //Меняет действие на противоположное
		    mIsIncrement = !mIsIncrement;
	    }

	    @Override
	    public void run() {
		    do {
			    if(!Thread.interrupted()) {	//Проверка прерывания
				    if(mIsIncrement) Program.mValue++;	//Инкремент
				      else Program.mValue--;			//Декремент
				
				    //Вывод текущего значения переменной
				    System.out.print(Program.mValue + " ");
			    } else return;		//Завершение потока	

			    try {
				      Thread.sleep(1000);		//Приостановка потока на 1 сек.
			    } catch(InterruptedException e) {
				      return;	//Завершение потока после прерывания
			    }
		    } while(true); 
	    }
    }

    class Program {
	    //Переменая, которой оперирует инкременатор
	    public static int mValue = 0;
	
	    static Incremenator mInc;	//Объект побочного потока

	    public static void main(String[] args) {
		    mInc = new Incremenator();	//Создание потока
		
		    System.out.print("Значение = ");
		
		    mInc.start();	//Запуск потока
		
		    //Троекратное изменение действия инкременатора
		    //с интервалом в i*2 секунд
		    for(int i = 1; i <= 3; i++) {
			    try{
				    Thread.sleep(i*2*1000);		//Ожидание в течении i*2 сек.
			    } catch(InterruptedException e){}
			
			    mInc.changeAction();	//Переключение действия
		    }
		
		    mInc.interrupt();	//Прерывание побочного потока
	    }
    }

    Консоль:
    Значение = 1 2 1 0 -1 -2 -1 0 1 2 3 4

Заметьте что методы **sleep**() и **join**() обёрнуты в конструкции try-catch. Это необходимое условие работы этих методов. Вызывающий их код должен перехватывать исключение InterruptedException, которое они бросают при прерывании во время ожидания.

# Concurrent коллекции

## Интерфейсы
пакет java.util.concurrency расширяет интерфейс очереди для определения новых ADT:

<img width="944" height="490" alt="image" src="https://github.com/user-attachments/assets/a301a677-6a46-4c17-bca3-8cf888629fbd" />

## Реализации

<img width="1321" height="518" alt="image" src="https://github.com/user-attachments/assets/bde0ee60-e8fc-457c-b42e-6b1cd64c206a" />

Все реализации коллекций в пакете java.util.concurrent являются потокобезопасными. В этих реализациях используется fine grained мелкозернистая блокировка/синхронизация для обеспечения потокобезопасности.

[ADT](https://www.logicbig.com/quick-info/software-engineering/abstract-data-type.html) - Abstract data type

| Реализация                | АТД (Абстрактный тип данных) | Структура данных и особенности                                                                                                                                                                                                                                                                                                                                 | Производительность (Big O нотация)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|---------------------------|------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ArrayBlockingQueue        | BlockingQueue                | Массив объектов. Ограниченный размер. Поддерживает политику справедливости. Если `fairness=true`, потоки гарантированно получают доступ в порядке FIFO. Классический ограниченный буфер.                                                                                                                                                                        | `offer`, `peek`, `poll`, `size`: **O(1)**<br>`put`, `take`: **O(1)** (если не учитывать время блокировки).<br>Справедливость обычно снижает пропускную способность, но предотвращает голодание producer/consumer.                                                                                                                                                                                                                                                                                                          |
| LinkedBlockingQueue       | BlockingQueue                | Связанная структура. Опционально ограниченный.                                                                                                                                                                                                                                                                                                                 | `offer`, `peek`, `poll`, `size`: **O(1)**<br>`put`, `take` используют отдельные блокировки, что увеличивает пропускную способность. Ещё выше, если не ограничен (нет блокировки из-за размера).<br>Менее предсказуемая производительность из-за динамического выделения памяти и фрагментации (удерживает блокировки дольше).                                                                                                                                                                                              |
| ConcurrentLinkedQueue     | Queue                        | Связанная структура. Неограниченный. Неблокирующий, но потокобезопасный. Запрещены `null`. Лучший выбор, чем `LinkedBlockingQueue`, когда много потоков обращаются к коллекции.                                                                                                                                                                                | Использует эффективный алгоритм **wait-free**:<br>`offer`, `peek`, `poll`: **O(1)**<br>`size`: **O(n)** (из-за асинхронной природы). Метод `size()` мало полезен в многопоточной среде, так как результат может быть неточным.<br>Итераторы **weakly consistent** (не кидают `ConcurrentModificationException` и не гарантируют актуальность данных).                                                                                                                                                                        |
| DelayQueue                | BlockingQueue                | Внутри использует `PriorityQueue` (куча). Неограниченный. Каждый элемент должен реализовывать `java.util.concurrent.Delayed`. Когда `getDelay()` возвращает `<= 0`, элемент доступен для извлечения, но всё ещё учитывается в `size()`. Запрещены `null`.                                                                                                        | `offer`, `poll`, `remove()`, `add`: **O(log n)**<br>`remove(Object)`, `contains(Object)`: **O(n)**<br>`peek`, `element`, `size`: **O(1)**                                                                                                                                                                                                                                                                                                                                                                                 |
| PriorityBlockingQueue     | BlockingQueue                | Бинарная куча. Неограниченный. Использует натуральный порядок или `Comparator`.                                                                                                                                                                                                                                                                                | `offer`, `poll`, `remove()`, `add`: **O(log n)**<br>`remove(Object)`, `contains(Object)`: **O(n)**<br>`peek`, `element`, `size`: **O(1)**<br>`put`: **O(log n)** (не блокируется, так как очередь неограниченная).<br>`take`: **O(log n)** (блокируется, пока не появится элемент).                                                                                                                                                                                                                                        |
| SynchronousQueue          | BlockingQueue                | Нет стандартной структуры. Реализует шаблон **rendezvous** (передача данных между потоками). Каждая операция вставки ждёт соответствующего удаления другим потоком и наоборот. Нет элементов в хранилище (только передача информации).                                                                                                                          | `put`, `offer`, `take`, `poll`: **O(1)**<br>Другие методы не имеют эффекта: `poll()` всегда возвращает `null`, `isEmpty()` — `false`, `size()` — `0`, `iterator()` — пустой итератор и т.д.                                                                                                                                                                                                                                                                                                                               |
| LinkedTransferQueue       | TransferQueue                | Связанная структура. Неограниченный. Похож на `SynchronousQueue`, но является формальной коллекцией с дополнительными методами (`tryTransfer`, `transfer` и др.). Если в очереди уже есть элементы и вызван `transfer`, он ждёт её опустошения, включая новый переданный элемент.                                                                                | `offer`, `peek`, `poll`: **O(1)**<br>`size`: **O(n)**<br>Все блокирующие методы снижают пропускную способность.<br>Обычно `LinkedTransferQueue` значительно быстрее `SynchronousQueue`.                                                                                                                                                                                                                                                                                                                                     |
| LinkedBlockingDeque       | BlockingDeque                | Двусвязные узлы. Опционально ограниченный. Лучший выбор, чем `LinkedBlockingDeque`, когда много потоков обращаются к коллекции.                                                                                                                                                                                                                                | `remove`, `removeFirstOccurrence`, `removeLastOccurrence`, `contains`, `iterator.remove()` и bulk-операции: **O(n)**<br>Остальные операции: **O(1)** (без учёта блокировки).                                                                                                                                                                                                                                                                                                                                               |
| ConcurrentLinkedDeque     | Deque                        | Двусвязные узлы. Неограниченный. Неблокирующий, но потокобезопасный. Запрещены `null`. Лучший выбор, чем `LinkedBlockingDeque` при многопоточном доступе.                                                                                                                                                                                                     | Индексные `get` и `remove`: **O(n)**<br>`size`: **O(n)** (ненадёжный из-за асинхронности).<br>Остальные методы: **O(1)**.<br>Итераторы **weakly consistent** (не кидают `ConcurrentModificationException`).                                                                                                                                                                                                                                                                                                                |
| CopyOnWriteArrayList      | List                         | Массивы объектов. Потокобезопасный. Все изменяющие методы (`add`, `set` и др.) создают новую копию массива.                                                                                                                                                                                                                                                    | `add`, `contains`, `remove(E e)`: **O(n)**<br>`get(Int index)`, `next`: **O(1)**<br>Блокировка только для записи. Дорогие операции записи (копирование массива).<br>Не рекомендуется при частых случайных изменениях.<br>Итераторы очень быстрые (без блокировок), но не поддерживают `remove`, `set`, `add` (`UnsupportedOperationException`).                                                                                                                                                                              |
| CopyOnWriteArraySet       | Set                          | Массивы объектов (внутри — `CopyOnWriteArrayList` с избеганием дубликатов через `addIfAbsent`). Потокобезопасный.                                                                                                                                                                                                                                             | `add`, `contains`, `remove(E e)`: **O(n)**<br>`next`: **O(1)**<br>Поведение итераторов как у `CopyOnWriteArrayList`.                                                                                                                                                                                                                                                                                                                                                                                                      |
| ConcurrentSkipListSet     | NavigableSet                 | Основан на `ConcurrentSkipListMap` (структура **skip list**), где элементы — ключи мапы. Потокобезопасный. Вставка, удаление и доступ безопасны для многопоточности.                                                                                                                                                                                           | `contains`, `add`, `remove` и их варианты: **O(log n)**<br>`next`: **O(1)**<br>`size`: **O(n)** (ненадёжный из-за асинхронности).<br>Итераторы и сплитераторы **weakly consistent**.                                                                                                                                                                                                                                                                                                                                     |

## Fine-Grained vs. Coarse-Grained Locking
Fine-Grained (мелкозернистая блокировка)
— Использует множество локов для небольших частей данных.
— Плюсы: Высокий параллелизм (меньше contention).
— Минусы: Сложнее реализовать, возможны deadlocks.
Пример: ConcurrentHashMap блокирует отдельные сегменты, а не всю таблицу.

Coarse-Grained (крупнозернистая блокировка)
— Один лок на всю структуру данных.
— Плюсы: Простота реализации.
— Минусы: Низкая параллелизм (высокий contention).
Пример: Hashtable блокирует всю таблицу при операциях.

## Блокирующая vs. Неблокирующая очередь
Блокирующая (Blocking Queue)
— При пустой очереди: take() блокирует поток до появления элемента.
— При полной очереди: put() блокирует поток до освобождения места.
Пример: ArrayBlockingQueue, LinkedBlockingQueue.

Неблокирующая (Non-Blocking Queue)
— Использует атомарные операции (CAS — Compare-And-Swap).
— Потоки не блокируются, а повторяют попытку при конфликте.
Пример: ConcurrentLinkedQueue.

## Голодание (Starvation) Producer/Consumer
Производитель (Producer) — поток, добавляющий данные в очередь.

Потребитель (Consumer) — поток, забирающий данные.

Голодание возникает, когда:
— Производители заполняют очередь, и потребители не успевают её обрабатывать (consumer starvation).
— Или наоборот: потребители опустошают очередь, а производители не могут добавить данные (producer starvation).
Решение: Ограничение размера очереди или политика справедливости.

## Справедливость (Fairness)
Справедливая очередь гарантирует, что потоки получают доступ в порядке FIFO (первым пришёл — первым обслужен).

Несправедливая очередь может обслуживать потоки в произвольном порядке (например, чтобы увеличить throughput).
Пример:
— ArrayBlockingQueue(fair=true) — справедливая.
— SynchronousQueue(fair=false) — может дать преимущество "быстрым" потокам.

Компромисс: Справедливость снижает пропускную способность (throughput), но предотвращает голодание.

**CAS (Compare-And-Swap)** — атомарная операция для неблокирующих алгоритмов.

**Weakly Consistent Iterators** — итераторы, которые могут не отражать последние изменения (например, в ConcurrentHashMap).

**Throughput vs. Latency** — справедливость уменьшает throughput (кол-во операций в секунду), но улучшает latency (время отклика для отдельных потоков).

Пример: take() в ArrayBlockingQueue
Если очередь пуста, поток блокируется (не потребляет CPU).
Когда появляется новый элемент (put() или offer()), один из ждущих потоков пробуждается и забирает элемент.

Что происходит внутри?
    Поток вызывает take().
    Если очередь пуста, поток:
    Захватывает монитор очереди (внутренний ReentrantLock).
    Переходит в режим ожидания (await() на Condition).
    Освобождает монитор (чтобы другие потоки могли добавлять элементы).
    Когда другой поток добавляет элемент (put()), он:
    Захватывает монитор.
    Добавляет элемент.
    Пробуждает один из ждущих потоков (signal() на Condition).
    Поток, который ждал, перехватывает монитор и забирает элемент.

| Критерий |	Блокирующая очередь (ArrayBlockingQueue)	| Неблокирующая очередь (ConcurrentLinkedQueue)  |
|----------|--------------------------------------------|------------------------------------------------|
| Блокировка |	Да (put()/take() ждут)	| Нет (использует CAS-операции) |
| Производительность |	Медленнее (из-за блокировок) |	Быстрее (нет блокировок) |
| Голодание	| Возможно (если fair=false)	| Нет (все потоки конкурируют через CAS) |
| Использование CPU |	Нет (поток спит)	| Да (поток повторяет попытки) |

## Важные моменты
Производительность всех вышеперечисленных реализаций (конкурентных коллекций) связана с блокировками и синхронизацией.
Если коллекцию использует только один поток, лучше выбрать обычные несинхронизированные коллекции из java.util (например, ArrayList вместо CopyOnWriteArrayList).

### Сравнение реализаций:
Очереди на основе связного списка (LinkedBlockingQueue, ConcurrentLinkedQueue)
— Эффективнее обычного LinkedList (который тоже реализует Deque), так как не поддерживают поиск или удаление по индексу (это операции O(n)).

### Сценарии "Producer-Consumer"
— Для двух потоков (один производитель, один потребитель) подходят блокирующие очереди (BlockingQueue).
— Для множества потоков — конкурентные реализации (ConcurrentLinkedQueue, ConcurrentLinkedDeque).

### Почему конкурентные коллекции лучше Collections.synchronizedXYZ()?
Collections.synchronizedList()/synchronizedQueue() синхронизируют все методы на одном общем мониторе (this), что позволяет работать только одному потоку за раз.

Конкурентные коллекции используют мелкозернистые блокировки (например, lock striping в ConcurrentHashMap), что повышает параллелизм.

Когда всё же использовать Collections.synchronizedXYZ()?
— При низкой конкуренции (мало потоков).
— Если нужно гарантировать, что изменения сразу видны всем потокам (strong consistency).
— Важно: При использовании итераторов требуется внешняя синхронизация, иначе возможно ConcurrentModificationException.

### Ключевые выводы

| Ситуация |	Рекомендуемая реализация |	Причина |
|-----|----|----|
| Один поток |	Обычные коллекции (ArrayList) |	Нет накладных расходов на синхронизацию. |
| Producer-Consumer (2 потока)	| BlockingQueue |	Простота и предсказуемость блокировок. |
| Много потоков |	ConcurrentLinkedQueue |	Высокий параллелизм за счёт CAS и мелкозернистых блокировок. |
| Требуется strong consistency |	Collections.synchronizedList() | Все изменения видны сразу, но низкий throughput. |

<img width="823" height="2296" alt="image" src="https://github.com/user-attachments/assets/2194ee0a-cddc-47a0-8b3f-76c73ccb5278" />

# Семафоры
