# Принципы ООП

Всюду разнятся принципы: где-то их 4 и добавляют абстракцию, где-то добавляют механизм позднего связывания. Однако 3 непоколебимых принципа должен знать каждый:
* Инкапсуляция
* Наследование
* Полиморфизм
*  + Абстракция
*  + Позднее связывание

## Инкапсуляция 

В теории:
_Инкапсуляция (encapsulation)_ - это механизм, который объединяет данные и код, манипулирующий этими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования.
На практике (чаще всего):
* все поля private (кроме констант). Могут устанавливаться другие модификаторы, но крайне редко;
* к полям предоставляется доступ через get (геттеры - для получения значения) и set (сеттеры - для установки значения) методы:

      public class SimpleExample {
          private int id;

          //Геттер не имеет входных параметров, возвращает значение поля
          public int getId() {
            return id;
          }

          //Сеттер имеет возвращаемый тип - void. Принимаемый - соответствует типу поля
          public void setId(int id) {
            this.id = id;
            //также тут можно сделать проверку перед установкой значения. Но чаще всего перед установкой значения его проверяют до вызова set метода.
            //Все зависит от ситуации. Но не рекомендуется делать проверку в сеттере, поскольку пользователь (как ему кажется) присваивает одно значение, а затем - получает другое
          }
      }

* **set** или **get** методов _может и не быть_, если это обусловлено. Например. Если переменная должна изменяться только внутри класса, то сеттера быть не должно.
* Учитывайте, что _геттер_, который возвращает ссылочный тип, _возвращает копию ССЫЛКИ_, а не _ОБЪЕКТА_ -> **пользователь через get метод может изменять объект**. Такое поведение, зачастую, _неприемлемо_. В идеале возвращать клон объекта (**переопределенный метод clone()**)

## Наследование

Наследование (inheritance) - это процесс, посредством которого, один объект может наследовать свойства другого объекта и добавлять к ним черты, характерные только для него.
Наследование бывает двух видов:
* одиночное - когда каждый класс имеет одного и только одного предка;
* множественное - когда каждый класс может иметь любое количество предков.

Наследуются: 
* методы (если позволяет модификатор доступа)
* поля (если позволяет модификатор доступа).

Например private методы или поля не наследуются. Однако, если у поля есть публичные геттеры или сеттеры, до доступ к переменной можно получить.

Наследование от класса (можно унаследоваться только от 1 класса):

    public class A extends B {...}

Реализация интерфейсов (интерфейсов может быть сколь угодно множество):

    public class A implements B {...} 

где B - интерфейс

**!Важный момент!**
Если класс-наследник определяет свои собственные методы, то при создании ссылки типа родителя, методов наследника видно не будет!!
Есть два класса:

    public class Parent {
      private int id;

      //getter
      //setter
    }

    public class Child extends Parent {
        public void printId() {
          sout(getId());
        }
    }

    psvm() {
      Child child = new Child();
      child.printId(); //сработает

      Parent parentChild = new Child();
      parentChild.printId(); //ошибка компилляции. Необходимо приведение
    }

Решение: определить Parent интерфейсом либо абстрактным классом и определить метод printId(), чтобы он переопределялся классом-наследником (см. полиморфизм)

    public abstract class Parent {
        private int id;

        //getter
        //setter

        public abstract void printId();
    }

    public class Child extends Parent {

        @Override
        public void printId() {
          sout(getId());
        }
    }

    psvm() {
      Child child = new Child();
      child.printId(); //сработает

      Parent parentChild = new Child();
      parentChild.printId(); //теперь тоже сработает
    }

Если поле приватно, то у наследника не будет прямого доступа к этому полю, однако, если будут существовать геттеры и сеттеры, то поле может быть доступно и использованно посредством этих методов:

            public class Parent {

                private int id;

                //геттеры и сеттеры
                public void setId(id) {
                      this.id = id;
                }

                public int getId() {
                      return this.id;
                }
            }

            public class Child extends Parent {

                  public void someMethod() {
                        this.id; //недоступно
                        setId(5); //можно
                        getId(); //можно
                  }
            }

## Полиморфизм

**Полиморфизм (polymorphism)** - это свойство, которое позволяет одно и то же имя использовать для решения двух или более схожих, но технически разных задач.

**Полиморфизм** - один интерфейс, множество реализаций.

В ООП **полиморфизмом** чаще всего называют способность классов с одинаковой спецификацией (интерфейсом) определять различную реализацию, что, в свою очередь, позволяет клиентскому коду абстрагироваться от этой самой реализации и работать с классом, исходя из его спецификации. Например, ваш метод может ожидать получить на входе объект типа UserInterface, при этом не зная, с каким конкретным подтипом типа UserInterface он будет работать.

Пример:

      public interface Parent {

        void printInfo();
      }

      public class Child1 {
        @Override
        public void printInfo() {
         //одна реализация
        }
      }

      public class Child2 {
        @Override
        public void printInfo() {
          //вторая реализация
        }
      }

      public class SomeClass {

        //Метод не знает, что именно он использует - Child1 или Child2
        public void someMethod(Parent parent) {
          parent.printInfo();
        }
      }

## Динамическое связывание

**Динамическое связывание (dynamic binding)** – связывание, при котором ассоциация между ссылкой(именем) и классом не устанавливается, пока объект с заданным именем не будет создан на стадии выполнения программы.
Мы уже разобрались, что в зависимости от ссылки на объект того или иного подкласса, Java вызовет тот или иной _переопределенный метод printInfo()_. Но откуда компилятор знает - какой из методов _printInfo()_ необходимо будет вызвать? Ответ заключается в том, что компилятор этого не знает.
Присоединение вызова метода к телу метода называется связыванием. 

Если связывание производится перед запуском программы (на этапе компиляции или компоновки), оно называется _ранним_ (_early_) или _статическим_ (_static_) связыванием (_binding_).

Неоднозначность в работе метода _someMethod()_ связана именно с ранним связыванием: компилятор не может знать заранее, какой вариант метода _printInfo_() нужно будет вызвать, когда у него есть только ссылка на объект реализацию интерфейса _Parent_ (неизвестно какую).

Данная проблема решается благодаря позднему связыванию, то есть связыванию, проводимому во время выполнения программы, в зависимости от типа объекта. _Позднее (late) связывание (binding)_ также называют _динамическим (dynamic)_ или связыванием на этапе выполнения программы (_runtime binding_).
В реализации Java существует механизм для фактического определения типа объекта во время работы программы для вызова подходящего метода. Иначе говоря, компилятор не знает тип объекта, но механизм вызова метода определяет фактический тип объекта и вызывает соответствующее тело метода.
Для **всех методов** Java **используется механизм позднего связывания**, если только метод не был объявлен как **final** (приватные методы являются **final** по умолчанию).

Итак, подведем итоги:
* статическое связывание в Java происходит на этапе компиляции, тогда как динамическое связывание происходит во время выполнения программы (в runtime);
* для private, final и static методов, а также для полей используется статическое связывание, тогда как для остальных методов (такие методы в некоторых языках программированию называются виртуальными (virtual)) используется динамическое связывание;
* в статическом связывании используется тип ссылки, тогда как в динамическом связывании используется фактический тип объекта;
* перегруженные методы используют статическое связывание, тогда как переопределенные методы используют динамическое связывание.

# Простейшие классы и объекты

## Класс

Классом называется описание совокупности объектов с общими атрибутами, методами, отношениями и семантикой.
Классы определяют структуру и поведение некоторого набора элементов предметной области, для которой разрабатывается программная модель.

Класс: Дом
Объект: Дом: двухэтажный, красный, 30 окон, 3 подъезда

Каждый класс имеет свое имя, отличающее его от других классов, и относится к определенному пакету.
Имя класса в пакете должно быть уникальным.
Объявление класса имеет вид:

    [спецификаторы] class имя_класса [extends суперкласс] [implements список_интерфейсов]{
      /*определение класса*/
    }

    public class Point2D {
      private int x;
      private int y;
      public void setX(int _x) {
        x = _x;
      }
    
      public void setY(int _y) {
        y = _y;
      }
    
      public int getX() {
        return x;
      }
    
      public int getY() {
        return y;
      }
    }

Объект - конкретная реализация класса в виде сущности с четко определенными параметрами (вес - 10кг, цвет - зеленый), которые отражают её состояние, а также может обладать каким-то поведением.
Объект ООП - это совокупность переменных состояния и связанных с ними методов(операций). Эти методы определяют как объект взаимодействует с окружающим миром.

## Спецификаторы класса

Спецификатор класса может быть:
* public (класс доступен объектам данного пакета и вне пакета).
* final (класс не может иметь подклассов).
* abstract (класс содержит абстрактные методы, объекты такого класса могут создавать только подклассы).
По умолчанию спецификатор доступа устанавливается в friendly (класс доступен в данном пакете). Данное слово при объявлении вообще не используется и не является ключевым словом языка.

## Методы

Все функции определяются внутри классов и называются методами.
Объявление метода имеет вид:
   
    [спецификаторы] [static|abstract] возвращаемый_тип имя_метода([аргументы]) {
      /*тело метода*/
    } | ;

Невозможно создать метод, не являющийся методом класса или объявить метод вне класса.
Cпецификаторы доступа методов:

* static public
* final private
* protected abstract
* friendly native
* strictfp synchronized

Вызов метода:

        public class Test {
            public void someTest() {
                sout("hello");
            }
        }
        
        psvm() {
            Test test = new Test();
            test.someTest(); //Вызов метода
        }

## Поля

Данные – члены класса, которые называются полями или переменными класса, объявляются в классе следующим образом:

    **cпецификатор** _тип_ **_имя_**;

Cпецификаторы доступа полей класса:
* static public
* final private
* protected friendly
* transient volatile

## Конструкторы

Конструктор – это метод, который автоматически вызывается при создании объекта класса и выполняет действия только по инициализации объекта;
* Конструктор имеет то же имя, что и класс;
* Вызывается не по имени, а только вместе с ключевым словом new при создании экземпляра класса;
* Конструктор не возвращает значение, но может иметь параметры и быть перегружаемым.

        public class Book {
            private int price;
  
            public Book() {
                price = 0;
            }
  
            public Book(int price){
                setPrice(price);
            }

            public void setPrice(int price){
                this.price = price;
            }

            public int getPrice(){
                return price;
            }
        }

При наследовании, конструкторы вызываются поочередно, начиная с родителя до класса, объект которого создается. Если быть точным, то первым вызывается конструктор Object.

        public class Parent {
            public Parent() {
                //sout("Parent")
            }
        }

        public class Child1 extends Parent {
            public Child1() {
                //sout("Child1")
            }
        }

        public class Child2 extends Parent {
            public Child2() {
                //sout("Child2")
            }
        }

        psvm() {
            Parent p = new Child2();
            Вызов конструкторов: Object -> Parent -> Child1 -> Child2
        }
        
# Классы и объекты

## Перегрузка методов
**Overload (перегрузка метода)** – определение методов с одинаковым наименованием но различной сигнатурой. Фактически, такие методы – это совершенно разные методы с совпадающим наименованием. Сигнатура метода определяется наименованием метода, а также числом и типом параметров метода.

    public class DatePrinter {
      
      public int printDate(String s) {
        System.out.printf("String s=", s);
        return 1;
      }

      public void printDate(int day, int month, int year) {
        System.out.println("int day=" + day);
      }
      
      public static void printDate(Date d) {
        System.out.printf("Date d=", d);
      }
    }

* Перегрузка реализует «раннее связывание».
* Статические методы могут перегружаться нестатическими и наоборот – без ограничений.
* При непосредственной передаче объекта в метод выбор производится в зависимости от типа ссылки на этапе компиляции.

## Equals и ==
== - сравнивает ссылки
equals() - сравниваем ссылки ПО УМОЛЧАНИЮ. Необходимо переопределить, чтобы сравнивались значения

    public boolean equals(Object obj) {
       return (this == obj);
    }

## Типичное переопределение equals

Мы проводим все первоначальные проверки, о которых сказали выше. Если в итоге оказалось, что:
* мы сравниваем два объекта одного класса
* это не один и тот же объект
* мы сравниваем наш объект не c null

тогда мы переходим к сравнению значимых характеристик. В нашем случае — поля dnaCode двух объектов.

    @Override
    public boolean equals(Object o) {
       if (o == null) return false; //пустой объект
       if (this == o) return true; //Проверка не один ли это и тот же объект в куче
       if (o == null || getClass() != o.getClass()) return false; //соответствие класса
       Man man = (Man) o; 
       return dnaCode == man.dnaCode; //сверка всех полей
    }    

Основные правила:

* Рефлексивность.
Любой объект должен быть equals() самому себе.
Мы уже учли это требование. В нашем методе указано:
    if (this == o) return true;
  
* Симметричность.

Если a.equals(b) == true, то и b.equals(a) должно возвращать true.
Этому требованию наш метод тоже соответствует.

* Транзитивность.

Если два объекта равны какому-то третьему объекту, значит, они должны быть равны друг и другу.
Если a.equals(b) == true и a.equals(c) == true, значит проверка b.equals(c) тоже должна возвращать true.

* Постоянность.

Результаты работы equals() должны меняться только при изменении входящих в него полей. Если данные двух объектов не менялись, результаты проверки на equals() должны быть всегда одинаковыми.

* Неравенство с null.

Для любого объекта проверка a.equals(null) должна возвращать false
Это не просто набор каких-то «полезных рекомендаций», а именно жесткий контракт методов, прописанный в документации Oracle

## Метод hashCode()

Теперь поговорим о методе hashCode(). Зачем он нужен?

Ровно для той же цели — сравнения объектов.

Ответ прост: для повышения производительности.

Хэш-функция, которая представлена в Java  методом hashCode(), возвращает числовое значение фиксированной длины для любого объекта. В случае с Java метод hashCode() возвращает для любого объекта 32-битное число типа int. 

Сравнить два числа между собой — гораздо быстрее, чем сравнить два объекта методом equals(), особенно если в нем используется много полей.

Если в нашей программе будут сравниваться объекты, гораздо проще сделать это по хэш-коду, и только если они равны по hashCode() — переходить к сравнению по equals().

Таким образом, кстати, работают основанные на хеше структуры данных — например, известная тебе HashMap. Распределение объектов по бакетам в зависимости от хэшкода ключа.

Метод hashCode(), так же как и equals(), переопределяется самим разработчиком.

И так же, как для equals(), для метода hashCode() есть официальные требования, прописанные в документации Oracle:
1. Если два объекта равны (т.е. метод equals() возвращает true), у них должен быть одинаковый хэш-код.

Иначе наши методы будут лишены смысла. Проверка по hashCode(), как мы и сказали, должна идти первой для повышения быстродействия. Если хэш-коды будут разными, проверка вернет false, хотя объекты на самом деле равны (согласно нашему определению в методе equals()).

2. Если метод hashCode() вызывается несколько раз на одном и том же объекте, каждый раз он должен возвращать одно и то же число.

3. Правило 1 не работает в обратную сторону. Одинаковый хэш-код может быть у двух разных объектов.

Метод hashCode() возвращает int. int — это 32-битное число. У него есть ограниченное число значений — от -2,147,483,648 до +2,147,483,647. Иными словами, всего существует чуть больше 4 миллиардов вариантов числа int.

Такая ситуация (совпадение хэш-кодов у двух разных объектов) называется **коллизией**. 

Одна из задач программиста при переопределении метода hashCode() — сократить потенциальное число коллизий насколько это возможно.

В Java есть одна небольшая хитрость, которая используется для сокращения числа коллизий: при вычислении хэш-кода умножать промежуточный результат на нечетное простое число. **Чаще всего используется число 29 или 31**.

    @Override
    public int hashCode() {
       int result = model == null ? 0 : model.hashCode();
       result = 31 * result + manufactureYear;
       result = 31 * result + dollarPrice;
       return result;
    }

