# Сущность Spring

_Я постараюсь давать вырезки из книги и пояснять их более простыми словами, поскольку иногда слова в книге могут трактоваться слишком далекими от смысла (слишком непонятными) для тех, кто погружается в Spring
впервые. В некоторых моментах я буду описывать сам "из головы"._

По сути, Spring предлагает контейнер, часто называемый **контекстом приложения** Spring, который создает компоненты приложения и  управляет ими. Эти **компоненты, или bean-компоненты**, 
объединяются внутри контекста Spring, образуя полноценное приложение, подобно тому, как кирпичи, известковый раствор, древесина, гвозди, водопроводные трубы и проводка соединяются вместе, образуя дом. (с)

Из абзаца важно понять:
- У Spring есть некоторый контейнер, нызываемый контекстом приложения.
- Контекст приложения создает и управляет некими "bean-компонентами".
_Забегая вперед, bean-компоненты - ничто иное как экземпляры классов (объекты, если вам угодно), но за их создание и управление ими отвечает Spring.
Впоследствии, это значит, что мы практически откажемся от оператора **new**, поскольку практически все объекты для нас будет создавать Spring и отдавать в те части приложения,
куда мы их запросим_

Акт объединения bean-компонентов основан на шаблоне, известном как внедрение зависимостей (Dependency Injection, DI). 
В технологии внедрения зависимостей компоненты не создают и не поддерживают жизненный цикл других компонентов, от которых они зависят,
а полагаются в этом на отдельный объект (контейнер), который создаст все нужные компоненты и внедрит их в другие компоненты, которые в них нуждаются. Обычно это делается с помощью аргументов
конструктора или методов доступа к свойствам. (с)

Поясняю. 
Dependency Injection - это реализация Inversion of Control (инверсия управления).
По порядку:
- Inversion of Control (IoC) - принцип, предполагающий передачу некоторой работы программиста - фреймворку.
- Dependency Injection (внедрение зависимостей) - реализация IoC, которая подразумевает, что Spring занимается связыванием компонентов между друг другом и передачей объектов в необходимые места (представьте, что у вас есть
объект "Человек" (Human) у человека внутри есть ссылка на "Домашний питомец" (Pet). Так вот, DI занимается тем, **чтобы создать человека**, **создать питомца**, **внедрить созданного питомца в человека** (звучит так себе, зато понятно)
Без Spring мы бы сделали:

      ...
      Human human = new Human();
      Pet pet = new Cat();
      human.setPet(pet);
      ...
А теперь мы просто передали эту рутину Spring! Понимаю, пример абстрактный и все равно до конца непонятный. В конце статьи, когда введение закончится я приведу более конкретный пример.

- Контекст приложения - если говорить грубо, то это место, где Spring как раз и берет на себя управление вещами, перечисленными выше. То есть:
  - IoC - абстрактный принцип
  - DI - реализация принципа IoC
  - Application Context - по сути, тоже реализация IoC, но DI более узкое понятие. Скорее DI - механизм, внутри Application Context.

#### Вопрос, что с этим делать и как пользоваться?

- Как уже было сказано, Bean - это ничто иное как экземпляр класса. Значит, нам нужен любой POJO-класс.
- Spring'у нужно как-то сообщить, чтобы он управлял этим классом. Есть несколько способов:
  - Описать создание бина через класс-конфигурацию (аннотация @Configuration на класс и @Bean на метод, который будет возвращать нужный бин)
  - Описать бин через xml
  - Описать бин через аннотации @Component, @Repository, @Controller, @Service и так далее.
- Получить сам bean
  - либо по id-бина (который по умолчанию совпадает с названием класса, только с маленькой буквы) через контекст приложения (их множество реализаций, [см. тут](https://for-each.dev/lessons/b/-spring-application-context))
  - либо через внедрение зависимостей.

Пока без кода может быть непонятно, но далее станет понятнее

**В чем разница создания бинов?**

* Если мы настраиваем бин через @Configuration, то мы самостоятельно определяем процесс создания бина. То есть мы описываем метод, в котором происходит создание объекта:

      @Configuration
      public class MyConfig {

        @Bean
        public MyBean myBean() {
            MyBean bean = new MyBean();
            bean.setName("Это мой боб!");
            return bean;
        }
      }

Обратите внимание на название метода **myBean()**. Именно название метода задает конкретный идентификатор для бина, который будет доступен в контексте приложения.

Через xml почти то же самое. Так как я не использую xml, то не буду приводить пример. Их много в интернете.

Далее. Самое часто используемое - **автоконфигурация**. Дело в том, что спринг и без вас прекрасно (в БОЛЬШИНСТВЕ, но не всегда) случаев знает, что и как ему создавать. Ему нужно только "подсказать":

      @Component //подсказываем Spring, что это bean
      public class MyBean {
          private String name;

          //getters & setters      
      }

Буквально одной аннотацией мы говорим Spring: объекты этого класса - бины, теперь это твоя работа.

### Как происходит автоконфигурация?

Если мы говорим про Spring, то нам необходимо на главный класс (с методом main) добавить еще одну аннотацию: **@ComponentScan**.
Аннотация означает, что относительно этого класса в ЭТОМ пакете и ПОДПАКЕТАХ будет происходить сканирование бинов (аннотаций типа Component).
Spring сканирует пакеты и ищет эти аннотации, связывает бины между собой и вы больше не паритесь за создание бинов.
А еще нам на главный класс нужно повесить аннотацю: @EnableAutoConfiguration которая, как вы догадались, включает автоконфиги

В случае со Spring Boot нам не нужны эти аннотация, поскольку аннотации **@SpringBootApplication** и @EnableAutoConfiguration" в себе уже имеет @ComponentScan, что освобождает нас от лишней писанины (пусть и на две строчки, хотя @SpringBootApplication
содержит не только эти аннотации).

### Резюмируя создание бинов

Чаще всего мы используем над классом аннотации @Component, @Controller, @Service, @Repository для указания Spring, что эти классы являются бинами.

Но если нам нужна кастомная реализация бина, мы прописываем ее в @Configuration классе.

## В чем разница между @Component, @Controller, @Service, @Repository

Здесь есть некоторые хитрости, на которые очень легко попасться. В чем суть:

Практически в любой статье вы увидите подобное: _Данные аннотации носят маркерный характер для Spring и не несут в себе определенной функциональности. Например если у вас есть сервис, то вы можете пометить его как @Component
и все будет работать_

И это правда! Но лишь отчасти. Дьябло кроется в деталях:
@Controller, @Service и еже с ними подобные действительно что-то вроде "наследников" аннотации @Component (можно считать базовой единицой бина - абстракция), однако некоторые аннотации все же добавляют функциональность:

* Controller например не будет считан как контроллер, если он помечен как @Component.
* Repository - добавляет иерархию исключений, связанную с базами данных. То есть при возникновении SqlException Spring перехватит его, поймет что произошло и даст более понятный ответ, выкинув свое иключение. Если вы пометите репозиторий как @Component,
то, вероятно, получите старые добрые SqlException
* Service действительно не имеет под собой никакой функциональной подложки. Но я бы все равно рекомендовал его использовать, поскольку, никто не знает, будет ли добавлена новая функциональность в будущих версиях.

Будьте внимательны! Частый вопрос на собеседованиях про отличия.

## Как же использовать Bean's и "Запрашивать" их у Spring?

Здесь полностью раскрывается понятие ВНЕДРЕНИЕ зависимостей.
Внедрение - получение наших бинов "извне". То есть получени их от Spring, который их создал.

Начнем с приемов внедрения, которых всего 3:
- через конструктор
- через поле (не надо так)
- через (метод) сеттер

И вот как это работает:
**Через поле:**

        @Service
        public class MyService {
            @Autowired
            private MyRepository myRepository;
        }

**Через конструктор (самый частый вариант)**

      @Service
      public class MyService {
      
          private final MyRepository myRepository;

          @Autowired
          public MyService(MyRepository myRepository) {
              this.myRepository = myRepository
          }
      }

**Через метод:**

      @Service
      public class MyService {

          private MyRepository myRepository;

          @Autowired
          public void setMyRepository(MyRepository myRepository) {
              this.myRepository = myRepository;
          }
      }

Какой способ использовать - вкусовщина. У каждого есть свои плюсы и минусы. Тема достаточно философская и неплохо описана [тут](https://habr.com/ru/articles/490586/)
Как видно из кода, появилась новая аннотация **@Autowired**, что дословно - автоматически связанный. Эта аннотация-маркер, которая показывает, что данное значение будет автоматически получено от Spring.
Ее можно и не писать, Spring определит, что сюда необходимо прислать Bean с таким-то классом (интерфейсом)

В любом случае, магия уже произошла и отсюда никуда не деться. В любом из представленных случаев, мы можем взаимодействовать с myRepository, как с обычным объектом! Хотя мы нигде не писали new MyRepository;
Скажу вам больше, MyRepository может быть интерфейсом!

        @Repository
        interface MyRepository {

            String getById();
        }

        @Repository
        public class MyCustomRepository implements MyRepository {

            @Override
            public String getById() {
                //... реализация
            }
        }

И в данном случае, Spring создаст объект типа MyCustomRepository и поместит ссылку в myRepository!

.........................................................ОФФТОП.........................................................

Пока далеко не ушли. В 90% случаев, на проектах применяется [Lombok](https://habr.com/ru/companies/piter/articles/676394/) - библиотека синтаксического сахара. Добавляет кучу аннотаций для уменьшения вашего кода:

- @Getter @Setter - генерирует геттеры и сеттеры класса на основе полей
- @Data - геттеры, сеттеры, equals, hashcode, toString
- @ToString - понятно
- ... и так далее.

В ломбоке есть также такие аннотации:
- @NoArgsConstructor - генерация конструктора без параметров
- @AllArgsConstructor - генерация конструктора со всеми параметрами для всех полей
- @RequiredArgsConstructor - генерация конструктора для полей с final

И в комбинации со Spring мы можем добиться еще большего сокращения кода:

        @RequiredArgsConstructor
        public class MyBean {
            private final MyRepository myRepository;
        }

        @Setter
        public class MyBean {
            private MyRepository myRepository;
        }

Главное, в Intellij Idea включите в настройках Annotation Processing (без него lombok не работает).

Полезная библиотека, которая позволяет сильно сократить лишний код.

.........................................................ОФФТОП ОКОНЧЕН.........................................................

### Qualifier, Primary

И последний вводный вопрос, который будет разобран - приоритезация бинов.
В общем, представим ситуацию:

        @Repository
        public interface MyRepository {
        }

        @Repository
        public class MyCustomRepository implements MyRepository {}

        @Repository
        public class MySuperCustomRepository implements MyRepository {}
        ...

        @RequiredArgsConstructor
        public class Main {            
            private final MyRepository myRepository; //пу.пу.пу... И какую реализацию взять?
        }

И вот встал вопрос... Какую же реализацию использовать Spring? Он этого не знает, поэтому выбросит вам Runtime исключение.

Как раз для этих случаев и есть приоретизация с помощью @Qualifier и @Primary.
Все на самом деле просто:

- Желательно, но не обязательно дать компонентам имена:

        @Repository("customRep")
        public class MyCustomRepository implements MyRepository {}

        @Repository("superRep")
        public class MySuperCustomRepository implements MyRepository {}

по умолчанию, тогда имена (id) бинов были бы myCustomRepository и mySuperCustomRepository, соответственно.

- Указать @Qualifier("beanName") для уточнения, какую реализацию использовать:

**Пример для конструктора**

        public class Main {

            private final MyRepository myRepository;

            public MyBean(@Qualifier("superRep") MyRepository myRepository) {
                this.myRepository = myRepository;
            }
        }

**Пример для сеттера**

        public class Main {

            private MyRepository myRepository;

            public void setMyRepository(@Qualifier("superRep" MyRepository myRepository) {
                this.myRepository = myRepository;
            }
        }

**Пример для поля**

        public class Main {

              @Qualifier("superRep")
              private MyRepository myRepository;
        }

Как вы можете заметить, здесь нет Lombok. В этом минус. Lombok не сможет самостоятельно сгенерировать эти аннотации, поэтому в таких кейсах необходимо самому прописывать конструкторы и сеттеры.

Также есть другой способ приоретизации - с помощью аннотации **@Primary**. Когда данная аннотация "висит" на классе (либо на методе с аннотацией @Bean), то у нее будет первоочередный приоритет на внедрение:

        @Repository("customRep")
        @Primary
        public class MyCustomRepository implements MyRepository {}

        @Repository("superRep")
        public class MySuperCustomRepository implements MyRepository {}

        @RequiredArgsConstructor
        public class Main {            
            private final MyRepository myRepository; //будет загружена MyCustomRepository
        }
