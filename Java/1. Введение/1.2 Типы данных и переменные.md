# Типы данных, переменные

## 1.2.1 Примитивные типы

Язык Java является объектно-ориентированным, но существуют типы данных (простые/примитивные), не являющиеся объектами:
 * целые: **int, byte, short, long**;
 * числа с плавающей точкой: **float, double**;
 * символы: **char**;
 * логические: **boolean**.
Синтаксис Java позволяет создавать свои типы, получившие название ссылочных

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/43f01c8c-d3d6-4fb1-ba8e-954877d83fa8)

### Особенности
* Размер примитивных типов одинаков для всех платформ; за счет этого становится возможной переносимость кода
* Размер boolean неопределен. Указано, что он может принимать значения true или false.
* Преобразования между типом boolean и другими типами не существует.

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/800b7a1c-ce02-46d6-9db2-ea55294a448c)

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/14ae73e0-766c-4650-9505-af8eae6155b1)

### Значения по умолчанию
![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/5d6ba114-1c07-480c-9926-0f20eb7f74d5)

## 1.2.2 Переменные
Характеристики переменных:
 * основное место для хранения данных;
 * должны быть явно объявлены;
 * каждая переменная имеет тип, идентификатор и область видимости;
 * определяются для класса, для экземпляра и внутри метода. (имеется ввиду статические, нестатические и локальные)
Объявление переменных:
 * может быть объявлена в любом месте блока кода;
 * должна быть объявлена перед использованием;
 * обычно переменные объявляются в начале блока (или класса);
 * область видимости определяется блоком;
 * необходимо инициализировать переменные перед использованием;
 * переменные простых типов инициализируются автоматически.

 _В именах переменных не могут использоваться символы арифметических и
логических операторов, а также символ ‘#’._

Применение символов ‘$’ и ‘_’ допустимо, в том числе и в первой позиции имени.

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/e8e68c84-1053-4f98-be7f-175a9da9426d)


Кроме ключевых слов, в Java существуют три литерала: **null, true, false**,не относящиеся
к ключевым и зарезервированным словам. А также дополнительные зарезервированные
слова: **const, goto.**

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/6e7d9cb8-c476-4114-9f46-8afb7652f87e)

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/76dc439e-6091-4943-855b-113f700606fc)


![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/fdbf0b74-70c8-494a-8d48-8a93137cde6c)

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/5c2d7168-33d8-433c-b7e3-b8cf35d596cd)

## 1.2.3 Преобразование (приведение) примитивных типов

Java запрещает смешивать в выражениях величины разных типов, однако при числовых операциях такое часто бывает необходимо.
Различают:
 *повышающее (разрешенное, неявное)* преобразование;
 *понижающее (явное)* приведение типа.
_Расширяющее (повышающее) преобразование_. Результирующий тип имеет больший
диапазон значений, чем исходный тип.

    int x = 200;
    long y = (long)x;
    long z = x;
    long value1 = (long)200; //необязательно, т.к. компилятор делает это автоматически

_Неявное (повышающее) преобразование_ осуществляется автоматически, даже в случае потери данных.

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/7695014f-07d9-4daf-82ce-fceb5cc012c1)

Серыми стрелками обозначены преобразования, при которых может произойти потеря
точности.
    
_Сужающее (понижающее) преобразование_. Результирующий тип имеет меньший
диапазон значений, чем исходный тип.
    long value2 = 1000L;
    int value3 = (int)value2; //обязательно

При вычислении выражения (a @ b) аргументы a и b преобразовываются в числа, имеющие одинаковый тип:
 * если одно из числе double, то в double;
 * иначе, если одно из чисел float, то в float;
 * иначе, если одно из чисел long, то в long;
 * иначе оба числа преобразуются в int.

Арифметическое выражение над byte, short или char имеет тип int, поэтому для присвоения результата обратно в byte, short или char понадобится явное приведение типа.

### Особенности приведения вещественных чисел

Слишком _большое дробное число_ при приведении к целому превращается в **Integer.MAX_VALUE** или **Integer.MIN_VALUE**
Слишком большой _double_ при приведении к _float_ превращается в **Float.POSITIVE_INFINITY** или **Float.NEGATIVE_INFINITY**

## 1.2.4 Классы-оболочки

Кроме базовых типов данных широко используются соответствующие классы
(wrapper классы):
 * Boolean, Character, Integer, Byte, Short, Long, Float, Double.
 * Объекты этих классов могут хранить те же значения, что и соответствующие имбазовые типы.
 * Объекты этих классов представляют ссылки на участки динамической памяти, в которой хранятся их значения, и являются классами оболочками для значений базовых типов.
 * Объекты этих классов являются константными.

Классы-оболочки (кроме Boolean и Character) являются наследниками абстрактного класса Number и реализуют интерфейс Comparable, представляющий собой интерфейс для работы со всеми скалярными типами.

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/4b5d39a8-5540-4499-9ce6-cb58d287defa)

Класс **_Character_** не наследуется от **_Number_**, так как ему нет необходимости поддерживать интерфейс классов, предназначенных для хранения результатов арифметических операций.
Класс **_Character_** имеет целый ряд специфических методов для обработки символьной информации.
У этого класса, в отличие от других классов оболочек, _не существует конструктора с параметром типа String.

## 1.2.5 Big-классы

Java включает два класса для работы с высокоточной арифметикой:
**BigInteger и BigDecimal,**

которые поддерживают целые числа и числа с фиксированной точкой произвольной точности.

      import java.math.BigInteger;
      public class BigNumbers {
        public static void main(String[] args) {
          BigInteger numI1, numI2, bigNumI;
          numI1 = BigInteger.valueOf(1_000_000_000_000L);
          numI2 = numI1.multiply(numI1);
          System.out.println(numI2);
          
          numI2 = numI1.multiply(numI1).multiply(numI1);
          System.out.println(numI2);
          
          numI2 = numI1.multiply(numI1).multiply(numI1).multiply(numI1);
          System.out.println(numI2);
          
          numI2 = numI1.multiply(numI1).multiply(numI1)
               .multiply(numI1).multiply(numI1);

          System.out.println(numI2);
          numI2 = numI1.multiply(numI1).multiply(numI1).multiply(numI1)
               .multiply(numI1).multiply(numI1);
           
          System.out.println(numI2);
          }
      }

## 1.2.6 Автоупаковка (распаковка)

В версии **_5.0_** введен процесс автоматической инкапсуляции данных базовых типов в соответствующие объекты оболочки и обратно (_автоупаковка_). При этом нет необходимости в создании соответствующего объекта с использованием оператора new.

    Integer iob = 71;

Автораспаковка – процесс извлечения из объекта-оболочки значения базового типа. Вызовы таких методов, как intValue(), doubleValue() становятся излишними. Допускается участие объектов в арифметических операциях, однако не следует этим злоупотреблять, поскольку упаковка/распаковка является ресурсоемким процессом.

    public class AutoPack {
      public static void main(String[] args) {
        Integer j = 71; // создание объекта+упаковка
        Integer k = ++j; // распаковка+операция+упаковка

        int i = 2;
        k = i + j + k;
        System.out.println(k);
      }
    }

При автоупаковке значения базового типа возможны ситуации с появлением некорректных значений и непроверяемых ошибок.

    Number n1 = 1;
    Number n2 = 7.1;
    Number array[] = {71, 7.1, 7L};
    Integer i1 = (Integer)n1;
    Integer i2 = (Integer)n2; // runtime error
    Integer[] i3 = (Integer[])array; // runtime error
