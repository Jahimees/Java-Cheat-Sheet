# Понятие классов и объектов

## 1.4.1 Определения

Объект – некоторая КОНКРЕТНАЯ сущность моделируемой предметной области.
Класс – шаблон или АБСТРАКЦИЯ сущности предметной области.

Исходя из картинки ниже, слева - класс, справа - его конкретные реализации - квадраты разных размеров и цветов

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/39f9a696-f5ad-4630-b6e8-689e21b2ad47)

Классом называется описание совокупности объектов с общими атрибутами, методами, отношениями и семантикой. Классы определяют структуру и поведение некоторого набора элементов предметной области, для которой разрабатывается программная модель.

Объявление класса имеет вид:

    [спецификаторы] class имя_класса
    [extends суперкласс] [implements список_интерфейсов]{
      /*определение класса*/
    }

Под спецификаторами подразумеваются различные модификаторы доступа, а также объявления класса final, static, abstract, sealed и проч.

## 1.4.2 Sealed классы

* sealed (запечатанные) классы - классы, которые строго определяют свои классы-наследники.

    public sealed class Shape
      permits Circle, Rectangle, Square {...}

Из примера, класс Shape могут наследовать только классы Circle, Rectangle, Square
**_Разрешенные классы_** могут быть _final_, _sealed_ и _non-sealed_.

* Указание **_final_** предотвратит дальнейшее расширение этой части иерархии классов.
* **_sealed_** допускает расширение этой части иерархии за рамки первоначально определенного суперкласса, но только разрешенными им классами.
* И наконец, **_non-sealed_** открывает иерархию классов для расширения неизвестными подклассами. Однако, начиная с дочернего незапечатанного класса, суперкласс будет запечатан и недоступен для неизвестных расширений.

## 1.4.3 Свойства и методы класса

Определение класса включает:
 * модификатор доступа;
 * ключевое слово class;
 * свойства класса;
 * конструкторы;
 * методы;
 * статические свойства;
 * статические методы.
**Объект состоит из следующих частей:**
 * тип объекта (класс, к которому он принадлежит);
 * ссылка на объект (переменная, содержащая ссылку на объект. может отсутствовать, если объект применяется "на месте")
 * состояние (переменные состояния);
 * методы (операции).
**Свойства классов:**
 * уникальные характеристики, которые необходимы при моделировании (примеры: размер, скорость, имя, возраст) предметной области
 * ОБЪЕКТЫ различаются значениями свойств
 * свойства отражают состояние объекта
**Методы классов:**
 * метод отражает ПОВЕДЕНИЕ объектов
 * выполнение методов, как правило, меняет значение свойств
 * поведение объекта может меняться в зависимости от состояния

## 1.4.4 Методы и функции

В настоящее время грань между методами и функциями стерлась практически окончательно. Ранее разделяли методы (ничего не возвращает - в возвращаемом типе указано void) и функции (что-то возвращает).
Однако, сегодня, как бы вы не называли, никто не придерется.

Все методы определяются внутри классов.
Обявление метода имеет следующий вид:

        [спецификаторы] [static|abstract] возвращаемый_тип
            имя_метода([аргументы]) {
                /*тело метода*/
        } | ;

_Невозможно создать метод, не являющийся методом класса или объявить метод вне класса._
Спецификаторы:
   * static
   * public, protected, private
   * friendly (по умолчанию, если не указан public protected или private
   * synchronized
   * final
   * native
   * abstract
   * strictfp

## 1.4.5 Поля, свойства

Поля отражают СОСТОЯНИЕ объекта, его характеристики и свойства
Данные – члены класса, которые называются полями или переменными класса, объявляются в классе следующим образом:

**cпецификатор** _тип_ **_имя_**;
Cпецификаторы доступа полей класса:
    * static 
    * public, private, protected 
    * final 
    * friendly 
    * transient 
    * volatile

## 1.4.6 Конструкторы

Конструктор - метод класса, который вызывается единожды для каждого объекта при его создании (при вызове new)
* Конструктор имеет то же имя, что и класс.
* Вызывается не по имени, а только вместе с ключевым словом new при
создании экземпляра класса.
* Конструктор не возвращает значение, но может иметь параметры и быть
перегружаемым.

Создание объекта:

**_имя_класса_** _имя_переменной_ = **new** _конструктор_класса_(аргументы);

**При наследовании, вызываются все конструкторы по иерархии сверху вниз:**

        class Animal {
            public Animal() {
             sout("hello ");
            }
        }

        class Cat extends Animal {
            public Cat() {
                sout("cat");
            }
        }

_В данном случае, вызываются конструкторы Object -> Animal -> Cat. Все классы наследуются от Object по умолчанию_

## 1.4.7 Передача параметров в методы

Представим, что есть метод:

        public void changeIt(int primary, Integer obj) {
            primary = primary + 10;
            obj = obj + 10;
        }

        //где-то в коде
        int prim = 5;
        Integer ob = new Integer(5);
        changeIt(prim, ob); //передача параметров в метод
        sout(prim); //5
        sout(ob); //15

Казалось бы, выполняются одни и те же действия, а результаты разные.
Ссылочные типы передаются в метод по ссылке (т.е. копируется ссылка на объект, но действия над объектом те же).
Примитивные типы передаются в метод по значению (копируется само значение в метод, а не ссылка. Поэтому изменения в методе не повлияют на переменную)

_При передаче в метод аргумента-ссылки можно изменить состояние объекта и оно сохранится после возвращения из метода, так как в этом случае нового объекта не создается, а создается лишь новая ссылка, указывающая на старый объект._

! **Из этого правила существует одно исключение – когда передается ссылка, указывающая на константный объект.**
 * Константный объект – это такой объект, изменить состояние которого нельзя. При попытке его изменить создается новый модифицированный объект. Примером таких объектов являются объекты класса String.
 * Если необходимо вернуть в вызывающий метод ссылку на новый константный объект, созданный в этом методе, следует указать её тип как тип возвращаемого методом значения и использовать return.

## 1.4.8 Основы работы со строками

Создание:
String str = new String("hello");
либо
String str = "hello";
В чем разница? 
В первом случае 100% создается новый объект в так называемом "пуле строк" - место, где хранятся все литералы.
Во втором случае, java сначала проверяет существование такого литерала в пуле. если его нет - создает и возвращает ссылку на него. Если же такой литерал существует, то просто возвращает на него ссылку.

Пул литералов – это коллекция ссылок на строковые объекты.
 * Пул литералов представляет все литералы, созданные в программе.
 * Каждый раз, когда создаются строковые литералы, аналогичный литерал ищется в пуле.
 * Если создаваемый литерал уже существует в пуле, то новый экземпляр для него не создается, а возвращается адрес уже имеющегося.

* Знак + применяется для объединения двух строк.
* Если в строковом выражении применяется нестроковый аргумент, то он преобразуется к строке автоматически.

Чтобы сравнить на равенство две строки необходимо воспользоваться методом **equals()**, так как '==' сравнивает ссылки (указывают ли ссылки на один и тот же объект?), а equals у строк переопределен на сравнение значений:

        if(str1.equals(str2)){}

Длина строки определяется с помощью метода **length()**:
        
        int len = str.length();
