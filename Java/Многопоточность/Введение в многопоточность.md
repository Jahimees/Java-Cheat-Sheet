_Источники_
_https://habr.com/ru/articles/745910/_
_https://javarush.com/groups/posts/1878-mnogopotochnostjh-v-java_
_https://habr.com/ru/articles/164487/_

## Введение. Основные понятия

**Процесс** - это экземпляр выполняющейся программы, простыми словами при запуске любой программы на вашем компьютере, вы порождаете процесс. Он имеет свое собственное адресное пространство памяти и один или несколько потоков.

Process (процесс) – выполняющийся экземпляр программы, которому Операционная Система (ОС) выделила память, процессорное время/ядра и прочие ресурсы. Важно, что память выделяется отдельно, адресные пространства различных процессов недоступны друг другу. Если процессам необходимо обмениваться данными, они могут это сделать с помощью файлов, каналов и иных способов межпроцессного взаимодействия.

**Поток** - это последовательность инструкций, выполняющаяся внутри процесса. Потоки делят адресное пространство памяти процесса, что позволяет им работать параллельно.

Java Thread (поток). Иногда, чтобы не путать с другими классами Java – Stream и подобными, потоки Java часто переводят как нить. Они используют выделенные для процесса ресурсы и являются способом выполнения процесса. Главный поток выполняет метод main и завершается. При выполнении процесса могут порождаться дополнительные потоки (дочерние). Потоки одного процесса могут между собой обмениваться данными. Многопоточность Java требует учитывать синхронизацию данных, не забывайте об этом.

В Java процесс завершается тогда, когда закончил работу последний его поток. Для фоновых задач поток можно запустить как демон (daemon), отличие которого от обычного в том, что они будут принудительно завершены при окончании работы всех не-daemon потоков процесса. 

**Внутри** ПРОЦЕССА может быть множество ПОТОКОВ.

На самом деле потоки не работают параллельно друг другу. Программа выделяет потокам определенное процессорное время, в которое поток будет работать. То есть, потоки работают поочередно, просто меняются между собой очень-очень быстро.

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/cc405d93-6e93-4079-9897-2f2d5254f3e2)


## Состояния потока

Каждый поток пребывает в одном из следующих состояний (state):
* Создан (New) – очередь к кадровику готовится, люди организуются.
* Запущен (Runnable) – наша очередь выстроилась к кадровику и обрабатывается.
* Заблокирован (Blocked) – последний в очереди юноша пытается выкрикнуть имя, но услышав, что девушка в соседней группе начала делать это раньше него, замолчал.
* Завершён (Terminated) — вся очередь оформилась у кадровика и в ней нет необходимости.
* Ожидает(Waiting) – одна очередь ждёт сигнала от другой.

Организация потоков и их взаимодействие – это основа эффективной работы процессов.

## Базовые способы запуска потоков

Каждый процесс имеет хотя бы один выполняющийся поток. Тот поток, с которого начинается выполнение программы, называется главным. В языке Java, после создания процесса, выполнение главного потока начинается с метода main(). Затем, по мере необходимости, в заданных программистом местах, и при выполнении заданных им же условий, запускаются другие, побочные потоки.

Существует более полудюжины способов создания потоков. Для начала познакомимся базовыми.

### Способ 1

**Создать объект класса Thread, передав ему в конструкторе нечто, реализующее интерфейс Runnable. Этот интерфейс содержит метод run(), который будет выполняться в новом потоке. Поток закончит выполнение, когда завершится его метод run().**

    class SomeThing implements Runnable { //Нечто, реализующее интерфейс Runnable (содержащее метод run())
	    public void run() { //Этот метод будет выполняться в побочном потоке
		    System.out.println("Привет из побочного потока!");
    	}
    }

    public class Program { //Класс с методом main()
	    static SomeThing mThing;	//mThing - объект класса, реализующего интерфейс Runnable
	
	    public static void main(String[] args) {
		    mThing = new SomeThing();				
    
        Thread myThready = new Thread(mThing);	//Создание потока "myThready"
		    myThready.start();				//Запуск потока

		    System.out.println("Главный поток завершён...");
	    }
    }

!Для понимания того, что будет происходить дальше необходимо знать следующие понятия!
* [Анонимные классы](https://github.com/Jahimees/Java-Cheat-Sheet/blob/main/Java/%D0%A7%D0%B0%D1%81%D1%82%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B5%D0%BC%D1%8B/%D0%90%D0%BD%D0%BE%D0%BD%D0%B8%D0%BC%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B.md)
* [Лямбды](https://github.com/Jahimees/Java-Cheat-Sheet/blob/main/Java/%D0%A7%D0%B0%D1%81%D1%82%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B5%D0%BC%D1%8B/Stream%20%D0%B8%20lambda.md)

В случае, если мы знаем, что инструкции в классе SomeThing нам понадобятся всего 1 раз, то мы можем не плодить новый класс, а передать в new Thread(...) анонимный класс:

      public class Program {

          public static void main(String[] args) {
          
              Thread myThread = new Thread(new Runnable() {
              
                  public void run() {
                     System.out.println("Привет из побочного потока!");
                  }
              });

              myThread.start();
          }
      }

Далее, вспомним, что класс Runnable является функциональным, что дает нам возможность использовать лямбда:

      public class Program {

          public static void main(String[] args) {
              Thread myThread = new Thread(() -> System.out.println("Привет из побочного потока!"));
              myThread.start();
          }
      }

### Способ 2

**Создать потомка класса Thread и переопределить его метод run():**

Имеется специальный класс **Thread** в методе **run()** которого необходимо написать код, реализующий логику программы. После создания потока, можно запустить его, вызвав метод **start**().

Напишем демонстрационную программу, реализующую пример многопоточности  Java.

    class PeopleQueue extends Thread    {// Наша очередь из сотрудников, наследник класса Thread
      private String[] names;

      PeopleQueue(String... names) {// Конструктор, аргумент- массив имен сотрудников
          this.names = names;
      }

      @Override
      public void run() { // Этот метод будет вызван при старте потока
          for (int i = 0; i < names.length; i++) { // Вывод в цикле с паузой 0.5 сек очередного сотрудника
              System.out.println("Обработаны документы: " + names[i]);
              try {
                  sleep(500); // Задержка в 0.5 сек
              } catch (Exception e) {}
          }
      }
    }

    public class HR    {// Класс для демонстрации работы потока
      public static void main(String[] args) {
          // Создаем две очереди
          PeopleQueue queue1 = new PeopleQueue("Иван","Сергей","Николай","Фердинанд","Василий");
          PeopleQueue queue2 = new PeopleQueue("Мария","Людмила","Алиса","Карина","Ольга");

          System.out.println("Начали!"); // Сообщение из главного потока программы
          queue1.start();    //Запускаем одну очередь (дочерний поток)
          queue2.start(); //Запускаем вторую (дочерний поток)
      }
    }

## Демонстрация работы потоков

Для демонстрации параллельной работы потоков давайте рассмотрим программу, в которой два потока спорят на предмет философского вопроса «что было раньше, яйцо или курица?». Главный поток уверен, что первой была курица, о чем он и будет сообщать каждую секунду. Второй же поток раз в секунду будет опровергать своего оппонента. Всего спор продлится 5 секунд. Победит тот поток, который последним изречет свой ответ на этот, без сомнения, животрепещущий философский вопрос. В примере используются средства, о которых пока не было сказано (isAlive() sleep() и join()). К ним даны комментарии, а более подробно они будут разобраны дальше.

    class EggVoice extends Thread {
	    @Override
	    public void run() {
		    for(int i = 0; i < 5; i++) {
			    try {
				    sleep(1000);		//Приостанавливает поток на 1 секунду
			    } catch(InterruptedException e) {}
			
			    System.out.println("яйцо!");	
		    }
		    //Слово «яйцо» сказано 5 раз
	    }
    }

    public class ChickenVoice	{ //Класс с методом main()
	    static EggVoice mAnotherOpinion;	//Побочный поток
	
	    public static void main(String[] args) {
		    mAnotherOpinion = new EggVoice();	//Создание потока
		    System.out.println("Спор начат...");
		    mAnotherOpinion.start(); 			//Запуск потока
		
		    for(int i = 0; i < 5; i++) {
			    try {
				    Thread.sleep(1000);		//Приостанавливает поток на 1 секунду
			    } catch(InterruptedException e){}
			
			    System.out.println("курица!");
		    }		
		    //Слово «курица» сказано 5 раз
      
        if (mAnotherOpinion.isAlive()) { //Если оппонент еще не сказал последнее слово
			  try {  
				    mAnotherOpinion.join();	//Подождать пока оппонент закончит высказываться.
			  } catch(InterruptedException e) {}
			
			    System.out.println("Первым появилось яйцо!");
		    } else {	//если оппонент уже закончил высказываться
					System.out.println("Первой появилась курица!");
		    }
		    System.out.println("Спор закончен!");	
	    }
    }

    Консоль (Результат заранее непредсказуем):
    Спор начат...
    курица!
    яйцо!
    яйцо!
    курица!
    яйцо!
    курица!
    яйцо!
    курица!
    яйцо!
    курица!
    Первой появилась курица!
    Спор закончен!

Как было подмечено, заранее результат непредсказуем. Это происходит из-за так называемого «асинхронного выполнения кода». Асинхронность означает то, что нельзя утверждать, что какая-либо инструкция одного потока, выполнится раньше или позже инструкции другого. Или, другими словами, параллельные потоки независимы друг от друга, за исключением тех случаев, когда программист сам описывает зависимости между потоками с помощью предусмотренных для этого средств языка.

## Завершение потоков и демоны

В Java процесс завершается тогда, когда завершается последний его поток. Даже если метод main() уже завершился, но еще выполняются порожденные им потоки, система будет ждать их завершения.

Однако это правило не относится к особому виду потоков – **демонам**. Если завершился последний обычный поток процесса, и остались только потоки-демоны, то они будут принудительно завершены и выполнение процесса закончится. Чаще всего потоки-демоны используются для выполнения фоновых задач, обслуживающих процесс в течение его жизни.

Объявить поток демоном достаточно просто — нужно перед запуском потока вызвать его метод **setDaemon(true);**
Проверить, является ли поток демоном, можно вызвав его метод boolean **isDaemon();**

### Завершение потоков

В Java существуют (существовали) средства для принудительного завершения потока. В частности метод **Thread.stop()** завершает поток незамедлительно после своего выполнения. Однако этот метод, а также **Thread.suspend()**, приостанавливающий поток, и **Thread.resume()**, продолжающий выполнение потока, были объявлены устаревшими и **их использование отныне крайне нежелательно**. _Дело в том что поток может быть «убит» во время выполнения операции, обрыв которой на полуслове оставит некоторый объект в неправильном состоянии, что приведет к появлению трудноотлавливаемой и случайным образом возникающей ошибке._

Вместо принудительного завершения потока применяется схема, в которой каждый поток сам ответственен за своё завершение. Поток может остановиться либо тогда, когда он закончит выполнение метода run(), (main() — для главного потока) либо по сигналу из другого потока. Причем как реагировать на такой сигнал — дело, опять же, самого потока. Получив его, поток может выполнить некоторые операции и завершить выполнение, а может и вовсе его проигнорировать и продолжить выполняться. Описание реакции на сигнал завершения потока лежит на плечах программиста.

Java имеет встроенный механизм оповещения потока, который называется Interruption (прерывание, вмешательство), и скоро мы его рассмотрим, но сначала посмотрите на следующую программку:

Incremenator — поток, который каждую секунду прибавляет или вычитает единицу из значения статической переменной Program.mValue. Incremenator содержит два закрытых поля – mIsIncrement и mFinish. То, какое действие выполняется, определяется булевой переменной mIsIncrement — если оно равно true, то выполняется прибавление единицы, иначе — вычитание. А завершение потока происходит, когда значение mFinish становится равно true.

    class Incremenator extends Thread {
	    //О ключевом слове volatile - чуть ниже
	    private volatile boolean mIsIncrement = true;
	    private volatile boolean mFinish = false;

	    public void changeAction() { //Меняет действие на противоположное
		    mIsIncrement = !mIsIncrement;
	    }
     
	    public void finish() { //Инициирует завершение потока
		    mFinish = true;
	    }

	    @Override
	    public void run() {
		    do {
			    if(!mFinish) { //Проверка на необходимость завершения	
				    if(mIsIncrement) {
					    Program.mValue++;	//Инкремент
            } else {
					    Program.mValue--;	//Декремент
            }
    				
				    //Вывод текущего значения переменной
				    System.out.print(Program.mValue + " ");
			    } else return;		//Завершение потока

			    try{
				    Thread.sleep(1000);		//Приостановка потока на 1 сек.
			    } catch(InterruptedException e){}
		    } while(true); 
	    }
    }

    public class Program {
	    //Переменая, которой оперирует инкременатор
	    public static int mValue = 0;
	
	    static Incremenator mInc;	//Объект побочного потока

	    public static void main(String[] args) {
		    mInc = new Incremenator();	//Создание потока
		
		    System.out.print("Значение = ");
		
		    mInc.start();	//Запуск потока
		
		    //Троекратное изменение действия инкременатора
		    //с интервалом в i*2 секунд
		    for(int i = 1; i <= 3; i++) {
			    try {
				    Thread.sleep(i*2*1000); //Ожидание в течении i*2 сек.
			    } catch(InterruptedException e){}
			
			    mInc.changeAction();	//Переключение действия
		    }
		
		    mInc.finish();	//Инициация завершения побочного потока	
	    }
    }

    Консоль:
    Значение = 1 2 1 0 -1 -2 -1 0 1 2 3 4

Взаимодействовать с потоком можно с помощью метода **changeAction**() (для смены вычитания на сложение и наоборот) и метода **finish**() (для завершения потока).

В объявлении переменных **mIsIncrement** и **mFinish** было использовано ключевое слово **_volatile_** (изменчивый, не постоянный). _Его необходимо использовать для переменных, которые используются разными потоками_. Это связано с тем, что значение переменной, объявленной без volatile, может кэшироваться отдельно для каждого потока, и значение из этого кэша может различаться для каждого из них. 

**Объявление переменной с ключевым словом volatile отключает для неё такое кэширование и все запросы к переменной будут направляться непосредственно в память.** 

В этом примере показано, каким образом можно организовать взаимодействие между потоками. Однако есть одна проблема при таком подходе к завершению потока — Incremenator проверяет значение поля mFinish раз в секунду, поэтому может пройти до секунды времени между тем, когда будет выполнен метод finish(), и фактическим завершения потока. Было бы замечательно, если бы при получении сигнала извне, метод sleep() возвращал выполнение и поток незамедлительно начинал своё завершение. Для выполнения такого сценария существует встроенное средство оповещения потока, которое называется **Interruption** (прерывание, вмешательство).

### Interruption

Класс Thread содержит в себе скрытое булево поле, подобное полю mFinish в программе Incremenator, которое называется флагом прерывания. 
* Установить этот флаг можно вызвав метод interrupt() потока.
* Проверить же, установлен ли этот флаг, можно двумя способами.
  * Первый способ — вызвать метод bool isInterrupted() объекта потока,
  * Второй — вызвать статический метод bool Thread.interrupted().

**Первый метод** возвращает состояние флага прерывания и оставляет этот флаг нетронутым. 

**Второй метод** возвращает состояние флага и сбрасывает его. 

**Заметьте что Thread.interrupted()** — статический метод класса Thread, и его вызов возвращает значение флага прерывания того потока, из которого он был вызван. Поэтому этот метод вызывается только изнутри потока и позволяет потоку проверить своё состояние прерывания.

Итак, вернемся к нашей программе. Механизм прерывания позволит нам решить проблему с засыпанием потока. У методов, приостанавливающих выполнение потока, таких как **sleep(), wait() и join() **есть одна особенность — если во время их выполнения будет вызван метод _interrupt_() этого потока, они, не дожидаясь конца времени ожидания, **сгенерируют исключение InterruptedException**.

Переделаем программу Incremenator – теперь вместо завершения потока с помощью метода finish() будем использовать стандартный метод interrupt(). А вместо проверки флага mFinish будем вызывать метод bool Thread.interrupted();

Так будет выглядеть класс Incremenator после добавления поддержки прерываний:

    class Incremenator extends Thread {
	    private volatile boolean mIsIncrement = true;

	    public void changeAction() { //Меняет действие на противоположное
		    mIsIncrement = !mIsIncrement;
	    }

	    @Override
	    public void run() {
		    do {
			    if(!Thread.interrupted()) {	//Проверка прерывания
				    if(mIsIncrement) Program.mValue++;	//Инкремент
				      else Program.mValue--;			//Декремент
				
				    //Вывод текущего значения переменной
				    System.out.print(Program.mValue + " ");
			    } else return;		//Завершение потока	

			    try {
				      Thread.sleep(1000);		//Приостановка потока на 1 сек.
			    } catch(InterruptedException e) {
				      return;	//Завершение потока после прерывания
			    }
		    } while(true); 
	    }
    }

    class Program {
	    //Переменая, которой оперирует инкременатор
	    public static int mValue = 0;
	
	    static Incremenator mInc;	//Объект побочного потока

	    public static void main(String[] args) {
		    mInc = new Incremenator();	//Создание потока
		
		    System.out.print("Значение = ");
		
		    mInc.start();	//Запуск потока
		
		    //Троекратное изменение действия инкременатора
		    //с интервалом в i*2 секунд
		    for(int i = 1; i <= 3; i++) {
			    try{
				    Thread.sleep(i*2*1000);		//Ожидание в течении i*2 сек.
			    } catch(InterruptedException e){}
			
			    mInc.changeAction();	//Переключение действия
		    }
		
		    mInc.interrupt();	//Прерывание побочного потока
	    }
    }

    Консоль:
    Значение = 1 2 1 0 -1 -2 -1 0 1 2 3 4

Заметьте что методы **sleep**() и **join**() обёрнуты в конструкции try-catch. Это необходимое условие работы этих методов. Вызывающий их код должен перехватывать исключение InterruptedException, которое они бросают при прерывании во время ожидания.

С запуском и завершением потоков пока все. Далее будут рассмотрены методы, использующиеся при работе с потоками.


    
