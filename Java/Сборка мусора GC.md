_Источник: https://habr.com/ru/companies/otus/articles/776342/_
## Кратко о структуре памяти в JVM
### Куча (Heap)
**Куча** - это область памяти JVM, где хранятся все объекты Java и связанные с ними данные. Выделение памяти в куче происходит динамически во время выполнения программы.

Куча делится на несколько поколений для оптимизации сборки мусора:
**Молодое поколение (Young Generation)**: Сюда помещаются вновь созданные объекты. Это поколение далее делится на области: _Eden Space и две Survivor Spaces _(S0 и S1).

**Старое поколение (Old Generation)**: Содержит объекты, которые долго живут. Объекты перемещаются сюда из молодого поколения после того, как выживают несколько циклов сборки мусора.

**Постоянное поколение (PermGen, до Java 8)**: Хранилище метаданных классов и строк до Java 8.
Размер кучи и соотношение между её различными областями можно настроить с помощью параметров JVM, что позволяет оптимизировать управление памятью в зависимости от потребностей приложения.

### Стек (Stack)
_Каждый поток_ в Java имеет собственный стек, который содержит информацию о вызовах методов и локальных переменных. Стек устроен по принципу LIFO (last-in, first-out) и используется для управления выполнением методов и их локальными переменными.

Каждый вызов метода создает новый фрейм стека, который содержит локальные переменные метода, параметры и информацию о выполнении. После завершения метода фрейм стека удаляется, освобождая память.

Размер стека ограничен и может быть настроен при запуске JVM. Если стек переполнен (обычно из-за глубокой или бесконечной рекурсии), JVM выбросит исключение java.lang.StackOverflowError.

### Metaspace (замена PermGen в Java 8 и выше)
Metaspace используется для хранения метаданных классов и методов, в отличие от PermGen, который был удален в Java 8. В отличие от PermGen, Metaspace расширяется динамически, что помогает избежать ошибок OutOfMemoryError, связанных с метаданными классов.

Хотя Metaspace расширяется динамически, его максимальный размер все равно можно контролировать с помощью параметров JVM, что позволяет управлять потреблением памяти для метаданных.

### Автоматическое управление памятью
Когда в Java создается новый объект, JVM автоматически выделяет для него необходимое количество памяти в куче (heap). Размер памяти, выделяемый под каждый объект, определяется его структурой: какие поля он имеет, какие типы данных используются и так далее.

Пока объект активно используется (на него есть ссылки в программе), он остается в памяти. Объекты могут быть доступны в различных областях памяти кучи, таких как Young Generation, Old Generation, и PermGen (в старых версиях JVM) или Metaspace (в новых версиях).

Garbage Collector (GC) работает в фоновом режиме и периодически проверяет, какие объекты в памяти больше не доступны для приложения. Это достигается путем отслеживания ссылок на объекты. Объект считается "мусором", если на него нет активных ссылок.

Как только объект идентифицирован как недоступный, GC освобождает память, занимаемую этим объектом. Это освобождает ресурсы и делает память доступной для новых объектов.

Помимо освобождения памяти, GC также может участвовать в оптимизации распределения памяти, например, путем сжатия оставшейся кучи для предотвращения фрагментации памяти.

Хотя управление памятью автоматизировано, понимание принципов его работы важно для оптимизации производительности и избегания проблем, таких как задержки из-за длительных операций сборки мусора. Неэффективное использование памяти и неправильная работа с объектами могут привести к чрезмерной нагрузке на сборщик мусора, что в свою очередь может вызвать проблемы с производодительностью.

### Жизненный цикл объекта
Когда в Java создается новый объект (например, через оператор new), JVM выделяет для него память в куче (heap). Размер выделяемой памяти зависит от структуры объекта, включая его поля и связанные объекты.

После создания объект активно используется приложением. Это означает, что на объект существуют активные ссылки из других частей кода.

Обычные ссылки в Java являются сильными ссылками. Пока на объект есть хотя бы одна сильная ссылка, он остается в памяти.

Пример: MyClass myObject = new MyClass();

Java также предоставляет механизмы для создания слабых (WeakReference) и мягких (SoftReference) ссылок, которые позволяют GC удалять объекты, если это необходимо для освобождения памяти.

Если все сильные ссылки на объект обнулены или выходят из области видимости, объект становится недоступным для приложения.

Пример: myObject = null;

Когда выполнение блока кода завершается, все объекты, созданные в этом блоке и не связанные с внешними ссылками, также становятся недоступными.

GC периодически проверяет память на наличие объектов, которые больше не доступны (не имеют активных сильных ссылок. Этот процесс может быть инициирован автоматически или вручную (через вызов System.gc(), хотя его использование не рекомендуется).

После обнаружения недоступных объектов GC освобождает память, занимаемую этими объектами, делая её доступной для новых объектов.

Разные алгоритмы GC работают по-разному, и их эффективность может зависеть от характеристик приложения. Размеры областей памяти (например, Young и Old Generations) и другие параметры JVM также могут влиять на частоту и эффективность работы GC.

### Генерационная гипотеза
Большинство объектов в приложении имеют короткий жизненный цикл. Они быстро создаются и также быстро становятся недоступными для использования. Относительно небольшое количество объектов используется в течение длительного времени (или в течение всего времени работы приложения).

Для оптимизации работы с различными типами объектов, JVM делит кучу (heap) на несколько "поколений" или областей:

#### Young Generation:

Здесь размещаются вновь созданные объекты. Young Generation далее делится на три части: Eden Space и две Survivor Spaces (S0 и S1). Поскольку большинство объектов в Young Generation быстро становятся "мусором", GC (Minor GC) часто и быстро очищает эту область.

#### Old Generation:

Объекты, которые выжили после нескольких циклов сборки мусора в Young Generation, перемещаются в Old Generation. Здесь объекты существуют гораздо дольше, и очистка этой области (Major GC) происходит реже, но она более трудоёмка.

#### Permanent Generation или Metaspace:

В этой области хранятся метаданные классов и другая информация на уровне приложения. В более новых версиях Java (начиная с Java 8) PermGen был заменен на Metaspace, который управляется немного иначе и хранится не в основной куче.

### Работа GC с поколениями
#### Minor GC:

Young Generation в JVM делится на три части: одну область Eden и две Survivor области (S0 и S1). Новые объекты сначала размещаются в Eden. После заполнения Eden, Minor GC инициируется.

Minor GC начинается с поиска всех живых объектов в Eden и в одной из Survivor областей (которая активна в данный момент). Живые объекты копируются из Eden и активной Survivor области в другую Survivor область. Во время этого процесса, Eden и активная Survivor область очищаются.

Объекты, которые выживают после нескольких циклов Minor GC, перемещаются из области Survivor в Old Generation. Этот процесс называется "старением" объектов.

Minor GC выполняется часто и обычно занимает небольшое время, так как работает только с небольшими областями памяти. Поскольку он копирует объекты, а не удаляет их индивидуально, это снижает фрагментацию памяти.

#### Major GC или Full GC:

Old Generation предназначена для хранения долгоживущих объектов. Эта область больше по размеру по сравнению с Young Generation.

Major GC начинается с определения всех живых объектов в Old Generation. Все недоступные объекты удаляются. В отличие от Minor GC, этот процесс может включать уплотнение, чтобы уменьшить фрагментацию памяти.

Живые объекты могут быть перемещены для уменьшения фрагментации памяти, обеспечивая эффективное использование памяти для новых объектов.

Major GC выполняется реже, но является более трудоемким, так как обрабатывает больший объем памяти. Во время Major GC, приложение может испытывать более длительные паузы, так как это Stop-The-World процесс, где выполнение всех потоков приложения приостанавливается.

## Типы GC в JVM
### Serial Garbage Collector
Serial GC работает в однопоточном режиме, что означает, что во время сборки мусора все другие потоки приложения приостанавливаются (Stop-The-World пауза). Это самый простой и базовый сборщик мусора в JVM, без дополнительных сложностей многопоточной обработки или параллельной сборки мусора.

Когда Serial GC начинает процесс сборки мусора, он останавливает все другие потоки в приложении. Это означает, что выполнение приложения полностью приостанавливается на время сборки мусора.

Serial GC начинает с процесса маркировки, который определяет, какие объекты в куче все еще используются и должны быть сохранены. Он обходит все объекты, доступные из корневого набора (root set), который включает в себя глобальные переменные, активные потоки и т.д., маркируя каждый достижимый объект.

После маркировки GC удаляет все немаркированные объекты, освобождая занимаемую ими память. Это процесс называется очисткой.

В некоторых случаях, особенно если в куче много фрагментированной памяти, Serial GC может выполнить уплотнение. Это процесс, в ходе которого оставшиеся объекты перемещаются в непрерывный блок, что уменьшает фрагментацию памяти и упрощает последующее выделение памяти.

Не смотря на свою простоту и эффективность в средах с ограниченными ресурсами, SGC имеет ряд существенных недостатков.

Stop-The-World паузы могут быть проблематичными для приложений, требующих высокой отзывчивости или непрерывной работы.

Не подходит для многопроцессорных или многопоточных приложений, где требуется более высокая пропускная способность.

### Parallel Garbage Collector (Throughput Collector)
Parallel GC использует несколько потоков для выполнения задач GC, что позволяет эффективно использовать многопроцессорные системы. Основная цель - максимизация пропускной способности приложения, то есть максимальное количество работы, которое приложение может выполнить за единицу времени.

Как и Serial GC, Parallel GC также инициирует Stop-The-World паузы. Во время этих пауз все потоки приложения приостанавливаются для выполнения задач GC.

В этой фазе GC идентифицирует все живые объекты в куче. Это достигается путём обхода всех объектов, начиная с корневого набора (который включает в себя глобальные переменные и активные потоки). Многопоточность используется для ускорения процесса обхода и маркировки.

После того как "живые" объекты определены, GC удаляет недоступные объекты, тем самым освобождая память. Эта фаза также может выполняться многопоточно для ускорения процесса.

В некоторых случаях может проводиться уплотнение памяти для уменьшения фрагментации. Это включает перемещение живых объектов так, чтобы они занимали непрерывный блок памяти. Уплотнение улучшает последующее выделение памяти, но может увеличить время паузы GC.

PGC позволяет нам добиться улучшенной производительности на многопроцессорных и многопоточных системах. Но не смотря на это возможны более длительные Stop-The-World паузы по сравнению с более специализированными сборщиками мусора.

Резюмируя - не всегда идеален для приложений, где критично время отклика.

### Concurrent Mark-Sweep (CMS) Collector
CMS спроектирован для выполнения большей части своих задач одновременно с работой приложения, что минимизирует паузы, связанные с GC. Работа CMS делится на две основные фазы: фазу маркировки (Marking Phase) и фазу очистки (Sweeping Phase).

1. Фаза предварительной очистки (Initial Mark):

Это короткая Stop-The-World пауза, во время которой CMS маркирует корневые объекты, то есть объекты, доступные непосредственно из потоков приложения, глобальных переменных и т.д. Эта фаза быстра, но требует остановки всех потоков приложения.

2. Конкурентная фаза маркировки (Concurrent Marking):

В этой фазе, CMS продолжает процесс маркировки, обходя все объекты, достижимые из корневых объектов. Эта работа выполняется параллельно с выполнением приложения. Во время этой фазы приложение продолжает работать, что снижает влияние GC на время отклика приложения.

3. Фаза перемаркировки (Remark):

Это ещё одна короткая Stop-The-World пауза, во время которой CMS исправляет любые изменения, сделанные в куче после начала фазы конкурентной маркировки. Для оптимизации этого процесса часто используется алгоритм "снимка" (Snapshot-At-The-Beginning), который отслеживает изменения, произошедшие в куче с момента начала маркировки.

4. Конкурентная фаза очистки (Concurrent Sweeping):

После завершения маркировки, CMS удаляет немаркированные, а значит, недоступные объекты. Этот процесс также происходит параллельно с выполнением приложения. В результате, освобождается память, занимаемая недоступными объектами.

CMS обычно выбирают для серверных приложений и приложений в реальном времени, где важнее минимизировать время остановки, чем максимизировать пропускную способность или оптимизировать использование памяти. Однако, следует учитывать нагрузку на процессор и потенциальные проблемы с фрагментацией памяти, которая может быть из-за отсутствия уплотнения по умолчанию.

### G1 Garbage Collector
G1 (Garbage-First) Garbage Collecto отличается от традиционных подходов, таких как CMS или Parallel GC, своей способностью более эффективно управлять системными ресурсами.

G1 GC разделяет кучу на множество небольших областей (регионов), что позволяет более гибко управлять памятью. Эти регионы могут быть различных типов, включая Eden, Survivor, и Old. G1 GC приоритизирует сборку мусора в тех регионах, где это наиболее эффективно, основываясь на объеме мусора и затратах на его очистку.

Как и в CMS, G1 начинается с короткой Stop-The-World паузы для маркировки корневых объектов. Это включает в себя объекты, которые непосредственно доступны из потоков приложения, статические объекты и т.д.

G1 продолжает процесс маркировки, обходя все объекты, доступные из корневых объектов, параллельно с выполнением приложения. В это время приложение продолжает работать, что снижает влияние GC на время отклика.

Далее идет фаза Final Mark, включает еще одну короткую Stop-The-World паузу, во время которой G1 завершает процесс маркировки. В эту фазу включается обработка изменений, которые произошли в куче с момента начала конкурентной маркировки.

В последней фазе (сборке мусора) G1 собирает мусор из отдельных регионов. Это может включать перемещение живых объектов из одного региона в другой. Эта фаза также является Stop-The-World паузой, но ее длительность более предсказуема и обычно короче, чем в традиционных GC.

G1 Garbage Collector подходит для приложений с большим объемом кучи, где важны как производительность, так и предсказуемое время остановки. Он идеально подходит к примеру для серверных приложений.

### Z Garbage Collector (ZGC) и Shenandoah
Z Garbage Collector (ZGC) и Shenandoah предназначены для минимизации Stop-The-World (STW) пауз, что является маст хевом для приложений с требованиями к низкой задержке.

#### ZGC
ZGC разделяет кучу на набор мелких регионов. Это позволяет собирать мусор в каждом регионе независимо, что уменьшает время STW пауз. ZGC начинается с конкурентной фазы маркировки, которая происходит параллельно с работой приложения, минимизируя задержки.

Одной из ключевых особенностей ZGC является его способность к конкурентной релокации объектов. Это означает, что он может перемещать объекты во время работы приложения, что снижает необходимость в длительных STW паузах.

ZGC эффективно управляет фрагментацией памяти, регулярно уплотняя кучу во время работы приложения. ZGC использует цветные указатели и специальные барьеры чтения/записи для отслеживания доступных и перемещенных объектов, что позволяет оптимизировать процесс сборки мусора.

#### Shenandoah
Аналогично ZGC, Shenandoah выполняет большую часть работы по маркировке и компактизации конкурентно, то есть параллельно с выполнением приложения.

Shenandoah стремится минимизировать STW паузы, необходимые для некоторых задач сборки мусора. Shenandoah использует барьеры на пути выполнения для отслеживания доступа к объектам и их перемещения, что позволяет приложению продолжать работу во время сборки мусора.

Как и ZGC, Shenandoah активно управляет фрагментацией в куче, регулярно уплотняя пространство для эффективного выделения памяти.

Оба GC разработаны для обеспечения низких задержек в приложениях с большой кучей.

Подготовил небольшую обзорную табличку сравнения сборщиков:

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/abddb86f-8804-49a6-8a58-1d11838f7e38)
