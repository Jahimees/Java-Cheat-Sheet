_Источники: https://javarush.com/groups/posts/modifikator-static-java_

Модификатор **static** в Java напрямую связан с классом. Если поле статично, значит оно _принадлежит классу_, если метод статичный — аналогично: _он принадлежит классу_. Исходя из этого, можно обращаться к статическому методу или полю, используя имя класса. Например, если поле count статично в классе Counter, значит, вы можете обратиться к переменной запросом вида: **Counter.count**. 
+Переопределение и перегрузка

При обозначении переменной уровня класса мы указываем на то, что это значение относится к классу. Если этого не делать, то значение переменной будет привязываться к объекту, созданному по этому классу. 

* Если поле нестатическое, то у каждого объекта эта переменная своя.
* Если поле статическое, то для всех объектов, данное поле будет иметь одинаковое значение в любом случае.

Как правило, к статическим полям/методам обращаются по названию класса:

      MyClass.myStaticField;
      MyClass.myStaticMethod();

Однако, никто не мешает для этого использовать объект (хотя никто так не делает):

      MyClass myObj = new MyClass();
      myObj.myStaticField;
      myObj.myStaticMethod();

К слову, нам не обязательно иметь даже объект в такой ситуации:

      MyClass myObj = null;
      myObj.myStaticField;
      myObj.myStaticMethod();

### Статический блок

Есть два блока инициализации — обычный и статический.

Блок предназначен для инициализации внутренних переменных. Если блок обычный, то им инициализируют внутренние переменные объекта, если же статический, соответственно, им задают статические переменные (то есть переменные класса).

Пример класса со статическим блоком инициализации: 

      public class Car {
          static int km;

          static {
             km = 150;
          }
      }

Нестатический блок вызывается при каждом создании объекта.
Статический блок вызывается один раз при первом обращении к классу. Даже в том случае, если мы не обращаемся к статическим данным:

      MyClass myObj = new MyClass(); // Статический блок будет вызыван!

Порядок вызова следующий (при создании объекта):
**Статический блок - нестатический блок - конструктор**

### Статический метод

Статические методы отличаются от обычных тем, что они также привязаны к классу, а не к объекту.

_Важным свойством статического метода является то, что он может обратиться только к статическим переменным/методам._

### Статический класс в Java

Статическим классом может быть только внутренний класс.
[Подробнее про внутренние классы читать](https://github.com/Jahimees/Java-Cheat-Sheet/blob/main/Java/%D0%A7%D0%B0%D1%81%D1%82%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B5%D0%BC%D1%8B/%D0%92%D0%BD%D1%83%D1%82%D1%80%D0%B5%D0%BD%D0%BD%D0%B8%D0%B5%20%D0%B8%20%D0%B2%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B.md)

Опять же, этот класс привязан к внешнему классу, и если внешний наследуется другим классом, то этот не будет наследован. При этом данный класс можно наследовать, как и он может наследоваться от любого другого класса и имплементировать интерфейс.

По сути статический вложенный класс ничем не отличается от любого другого внутреннего класса за исключением того, что его объект не содержит ссылку на создавший его объект внешнего класса. 

Тем не менее, благодаря этому статический класс наиболее похож на обычный не вложенный, ведь единственное различие состоит в том, что он упакован в другой класс. В некоторых случаях для нас это преимущество, так как с него у нас есть доступ к приватным статическим переменным внешнего класса.

Пример вложенного статического класса:

      public class Vehicle {

        public static class Car {
           public int km;
        }
      }

Создание экземпляра данного класса и задание значения внутренней переменной:

      Vehicle.Car car = new Vehicle.Car();
      car.km = 90;

Для обращения к статическому методу/поля статического внутреннего класса необходимо указать название внешнего класса, название внутреннего класса и название метода/поля:

      MyOuterClass.MyNestedClass.myStaticMethod();
      MyOuterClass.MyNestedClass.myStaticField;

### Наследование

Статические методы переопределить нельзя (как будто). Их можно "скрыть". Вызов статического метода зависит от названия класса, через который вызываются методы. При вызове через ссылку, вызов метода зависит от ССЫЛКИ, а не от объекта. Представим, что есть два класса StaticTest и StaticChildTest. StaticChildTest extends StaticTest. При этом в StaticTest и StaticChildTest есть методы с одинаковой сигнатурой: **public static void printStaticValues()**:

        StaticTest st1 = new StaticTest();
        st1.printStaticValues(); //вызывается метод в StaticTest

        StaticTest st2 = new StaticChildTest();
        st2.printStaticValues(); //вызывается метод в StaticTest

        StaticChildTest st3 = new StaticChildTest();
        st3.printStaticValues(); //вызывается метод в StaticChildTest

При этом работает наследование. Представим, что в StaticChildTest нет метода printStaticValues. Что произойдет?

        StaticTest st1 = new StaticTest();
        st1.printStaticValues(); //вызов из StaticTest

        StaticTest st2 = new StaticChildTest();
        st2.printStaticValues(); //вызов из StaticTest

        StaticChildTest st3 = new StaticChildTest();
        st3.printStaticValues(); //вызов из StaticTest

        StaticChildTest.printStaticValues(); //вызов из StaticTest

Вывод: 
* статические методы НЕЛЬЗЯ переопределить (в привычном понимании)
* статические поля и методы НАСЛЕДУЮТСЯ
* статические методы МОЖНО перегрузить.

### Основные сведения

1. Вы НЕ можете получить доступ к НЕ статическим членам класса, внутри статического контекста, как вариант, метода или блока. Результатом компиляции приведенного ниже кода будет ошибка.
2. В отличие от локальных переменных, статические поля и методы НЕ потокобезопасны (Thread-safe) в Java. На практике это одна из наиболее частых причин возникновения проблем связанных с безопасностью мультипоточного программирования. Учитывая что каждый экземпляр класса имеет одну и ту же копию статической переменной, то такая переменная нуждается в защите — «залочивании» классом. Поэтому при использовании статических переменных, убедитесь, что они должным образом синхронизированы (synchronized), во избежание проблем, например таких как «состояние гонки» (race condition).
3. Статические методы имеют преимущество в применении, т.к. отсутствует необходимость каждый раз создавать новый объект для доступа к таким методам. Статический метод можно вызвать, используя тип класса, в котором эти методы описаны. Именно поэтому, подобные методы как нельзя лучше подходят в качестве методов-фабрик (factory), и методов-утилит (utility). Класс java.lang.Math — замечательный пример, в котором почти все методы статичны, по этой же причине классы-утилиты в Java финализированы (final).
4. Другим важным моментом является то, что вы НЕ можете переопределять (Override) статические методы. Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса (superclass) вместо переопределения. Это явление известно как сокрытие методов (hiding methods). Это означает, что при обращении к статическому методу, который объявлен как в родительском, так и в дочернем классе, во время компиляции всегда будет вызван метод исходя из типа переменной. В отличие от переопределения, такие методы не будут выполнены во время работы программы.
5. Объявить статическим также можно и класс, за исключением классов верхнего уровня. Такие классы известны как «вложенные статические классы» (nested static class). Они бывают полезными для представления улучшенных связей. Яркий пример вложенного статического класса — HashMap.Entry, который предоставляет структуру данных внутри HashMap. Стоит заметить, также как и любой другой внутренний класс, вложенные классы находятся в отдельном файле .class. Таким образом, если вы объявили пять вложенных классов в вашем главном классе, у вас будет 6 файлов с расширением .class. Ещё одним примером использования является объявление собственного компаратора (Comparator), например компаратор по возрасту (AgeComparator) в классе сотрудники (Employee).
6. Модификатор static также может быть объявлен в статичном блоке, более известным как «Статический блок инициализации» (Static initializer block), который будет выполнен во время загрузки класса. Если вы не объявите такой блок, то Java соберёт все статические поля в один список и выполнит его во время загрузки класса. Однако, статичный блок НЕ может пробросить перехваченные исключения, но может выбросить не перехваченные. В таком случае возникнет «Exception Initializer Error». На практике, любое исключение возникшее во время выполнения и инициализации статических полей, будет завёрнуто Java в эту ошибку. Это также самая частая причина ошибки «No Class Def Found Error», т.к. класс не находился в памяти во время обращения к нему.
7. Полезно знать, что статические методы связываются во время компиляции, в отличие от связывания виртуальных или не статических методов, которые связываются во время исполнения на реальном объекте. Следовательно, статические методы не могут быть переопределены в Java, т.к. полиморфизм во время выполнения не распространяется на них. Это важное ограничение, которое необходимо учитывать, объявляя метод статическим. В этом есть смысл, только тогда, когда нет возможности или необходимости переопределения такого метода классами-наследниками. Методы-фабрики и методы-утилиты хорошие образцы применения модификатора static.
8. Важным свойством статического блока является инициализация. Статические поля или переменные инициализируются после загрузки класса в память. Порядок инициализации сверху вниз, в том же порядке, в каком они описаны в исходном файле Java класса. Поскольку статические поля инициализируются на потокобезопасный манер, это свойство также используется для реализации паттерна Singleton. Если вы не используется список Enum как Singleton, по тем или иным причинам, то для вас есть хорошая альтернатива. Но в таком случае необходимо учесть, что это не «ленивая» инициализация. Это означает, что статическое поле будет проинициализировано ещё ДО того как кто-нибудь об этом «попросит». Если объект ресурсоёмкий или редко используется, то инициализация его в статическом блоке сыграет не в вашу пользу.
9. Во время сериализации, также как и transient переменные, статические поля не сериализуются. Действительно, если сохранить любые данные в статическом поле, то после десериализации новый объект будет содержать его первичное (по-умолчанию) значение, например, если статическим полем была переменная типа int, то её значение после десериализации будет равно нулю, если типа float – 0.0, если типа Object – null. Честно говоря, это один из наиболее часто задаваемых вопросов касательно сериализации на собеседованиях по Java.
10. И напоследок, поговорим о static import. Данный модификатор имеет много общего со стандартным оператором import, но в отличие от него позволяет импортировать один или все статические члены класса. При импортировании статических методов, к ним можно обращаться как будто они определены в этом же классе, аналогично при импортировании полей, мы можем получить доступ без указания имени класса.
11. 

        
