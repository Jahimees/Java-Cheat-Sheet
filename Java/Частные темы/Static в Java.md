_Источники: https://javarush.com/groups/posts/modifikator-static-java_

Модификатор **static** в Java напрямую связан с классом. Если поле статично, значит оно _принадлежит классу_, если метод статичный — аналогично: _он принадлежит классу_. Исходя из этого, можно обращаться к статическому методу или полю, используя имя класса. Например, если поле count статично в классе Counter, значит, вы можете обратиться к переменной запросом вида: **Counter.count**. 
+Переопределение и перегрузка

При обозначении переменной уровня класса мы указываем на то, что это значение относится к классу. Если этого не делать, то значение переменной будет привязываться к объекту, созданному по этому классу. 

* Если поле нестатическое, то у каждого объекта эта переменная своя.
* Если поле статическое, то для всех объектов, данное поле будет иметь одинаковое значение в любом случае.

Как правило, к статическим полям/методам обращаются по названию класса:

      MyClass.myStaticField;
      MyClass.myStaticMethod();

Однако, никто не мешает для этого использовать объект (хотя никто так не делает):

      MyClass myObj = new MyClass();
      myObj.myStaticField;
      myObj.myStaticMethod();

К слову, нам не обязательно иметь даже объект в такой ситуации:

      MyClass myObj = null;
      myObj.myStaticField;
      myObj.myStaticMethod();

### Статический блок

Есть два блока инициализации — обычный и статический.

Блок предназначен для инициализации внутренних переменных. Если блок обычный, то им инициализируют внутренние переменные объекта, если же статический, соответственно, им задают статические переменные (то есть переменные класса).

Пример класса со статическим блоком инициализации: 

      public class Car {
          static int km;

          static {
             km = 150;
          }
      }

Нестатический блок вызывается при каждом создании объекта.
Статический блок вызывается один раз при первом обращении к классу. Даже в том случае, если мы не обращаемся к статическим данным:

      MyClass myObj = new MyClass(); // Статический блок будет вызыван!

Порядок вызова следующий (при создании объекта):
**Статический блок - нестатический блок - конструктор**

### Статический метод

Статические методы отличаются от обычных тем, что они также привязаны к классу, а не к объекту.

_Важным свойством статического метода является то, что он может обратиться только к статическим переменным/методам._

### Статический класс в Java

Статическим классом может быть только внутренний класс.
[Подробнее про внутренние классы читать](https://github.com/Jahimees/Java-Cheat-Sheet/blob/main/Java/%D0%A7%D0%B0%D1%81%D1%82%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B5%D0%BC%D1%8B/%D0%92%D0%BD%D1%83%D1%82%D1%80%D0%B5%D0%BD%D0%BD%D0%B8%D0%B5%20%D0%B8%20%D0%B2%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B.md)

Опять же, этот класс привязан к внешнему классу, и если внешний наследуется другим классом, то этот не будет наследован. При этом данный класс можно наследовать, как и он может наследоваться от любого другого класса и имплементировать интерфейс.

По сути статический вложенный класс ничем не отличается от любого другого внутреннего класса за исключением того, что его объект не содержит ссылку на создавший его объект внешнего класса. 

Тем не менее, благодаря этому статический класс наиболее похож на обычный не вложенный, ведь единственное различие состоит в том, что он упакован в другой класс. В некоторых случаях для нас это преимущество, так как с него у нас есть доступ к приватным статическим переменным внешнего класса.

Пример вложенного статического класса:

      public class Vehicle {

        public static class Car {
           public int km;
        }
      }

Создание экземпляра данного класса и задание значения внутренней переменной:

      Vehicle.Car car = new Vehicle.Car();
      car.km = 90;

Для обращения к статическому методу/поля статического внутреннего класса необходимо указать название внешнего класса, название внутреннего класса и название метода/поля:

      MyOuterClass.MyNestedClass.myStaticMethod();
      MyOuterClass.MyNestedClass.myStaticField;

### Наследование

Статические методы переопределить нельзя (как будто). Их можно "скрыть". Вызов статического метода зависит от названия класса, через который вызываются методы. При вызове через ссылку, вызов метода зависит от ССЫЛКИ, а не от объекта. Представим, что есть два класса StaticTest и StaticChildTest. StaticChildTest extends StaticTest. При этом в StaticTest и StaticChildTest есть методы с одинаковой сигнатурой: **public static void printStaticValues()**:

        StaticTest st1 = new StaticTest();
        st1.printStaticValues(); //вызывается метод в StaticTest

        StaticTest st2 = new StaticChildTest();
        st2.printStaticValues(); //вызывается метод в StaticTest

        StaticChildTest st3 = new StaticChildTest();
        st3.printStaticValues(); //вызывается метод в StaticChildTest

При этом работает наследование. Представим, что в StaticChildTest нет метода printStaticValues. Что произойдет?

        StaticTest st1 = new StaticTest();
        st1.printStaticValues(); //вызов из StaticTest

        StaticTest st2 = new StaticChildTest();
        st2.printStaticValues(); //вызов из StaticTest

        StaticChildTest st3 = new StaticChildTest();
        st3.printStaticValues(); //вызов из StaticTest

        StaticChildTest.printStaticValues(); //вызов из StaticTest

Вывод: 
* статические методы НЕЛЬЗЯ переопределить (в привычном понимании)
* статические поля и методы НАСЛЕДУЮТСЯ
* статические методы МОЖНО перегрузить.

* 
        
