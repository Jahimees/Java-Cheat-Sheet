## Equals и ==
== - сравнивает ссылки
equals() - сравниваем ссылки ПО УМОЛЧАНИЮ. Необходимо переопределить, чтобы сравнивались значения

    public boolean equals(Object obj) {
       return (this == obj);
    }

## Типичное переопределение equals

Мы проводим все первоначальные проверки, о которых сказали выше. Если в итоге оказалось, что:
* мы сравниваем два объекта одного класса
* это не один и тот же объект
* мы сравниваем наш объект не c null

тогда мы переходим к сравнению значимых характеристик. В нашем случае — поля dnaCode двух объектов.

    @Override
    public boolean equals(Object o) {
       if (o == null) return false; //пустой объект
       if (this == o) return true; //Проверка не один ли это и тот же объект в куче
       if (o == null || getClass() != o.getClass()) return false; //соответствие класса
       Man man = (Man) o; 
       return dnaCode == man.dnaCode; //сверка всех полей
    }    

Основные правила:

* Рефлексивность.
Любой объект должен быть equals() самому себе.
Мы уже учли это требование. В нашем методе указано:
    if (this == o) return true;
  
* Симметричность.

Если a.equals(b) == true, то и b.equals(a) должно возвращать true.
Этому требованию наш метод тоже соответствует.

* Транзитивность.

Если два объекта равны какому-то третьему объекту, значит, они должны быть равны друг и другу.
Если a.equals(b) == true и a.equals(c) == true, значит проверка b.equals(c) тоже должна возвращать true.

* Постоянность.

Результаты работы equals() должны меняться только при изменении входящих в него полей. Если данные двух объектов не менялись, результаты проверки на equals() должны быть всегда одинаковыми.

* Неравенство с null.

Для любого объекта проверка a.equals(null) должна возвращать false
Это не просто набор каких-то «полезных рекомендаций», а именно жесткий контракт методов, прописанный в документации Oracle

## Метод hashCode()

Теперь поговорим о методе hashCode(). Зачем он нужен?

Ровно для той же цели — сравнения объектов.

Ответ прост: для повышения производительности.

Хэш-функция, которая представлена в Java  методом hashCode(), возвращает числовое значение фиксированной длины для любого объекта. В случае с Java метод hashCode() возвращает для любого объекта 32-битное число типа int. 

Сравнить два числа между собой — гораздо быстрее, чем сравнить два объекта методом equals(), особенно если в нем используется много полей.

Если в нашей программе будут сравниваться объекты, гораздо проще сделать это по хэш-коду, и только если они равны по hashCode() — переходить к сравнению по equals().

Таким образом, кстати, работают основанные на хеше структуры данных — например, известная тебе HashMap. Распределение объектов по бакетам в зависимости от хэшкода ключа.

Метод hashCode(), так же как и equals(), переопределяется самим разработчиком.

И так же, как для equals(), для метода hashCode() есть официальные требования, прописанные в документации Oracle:
1. Если два объекта равны (т.е. метод equals() возвращает true), у них должен быть одинаковый хэш-код.

Иначе наши методы будут лишены смысла. Проверка по hashCode(), как мы и сказали, должна идти первой для повышения быстродействия. Если хэш-коды будут разными, проверка вернет false, хотя объекты на самом деле равны (согласно нашему определению в методе equals()).

2. Если метод hashCode() вызывается несколько раз на одном и том же объекте, каждый раз он должен возвращать одно и то же число.

3. Правило 1 не работает в обратную сторону. Одинаковый хэш-код может быть у двух разных объектов.

Метод hashCode() возвращает int. int — это 32-битное число. У него есть ограниченное число значений — от -2,147,483,648 до +2,147,483,647. Иными словами, всего существует чуть больше 4 миллиардов вариантов числа int.

Такая ситуация (совпадение хэш-кодов у двух разных объектов) называется **коллизией**. 

Одна из задач программиста при переопределении метода hashCode() — сократить потенциальное число коллизий насколько это возможно.

В Java есть одна небольшая хитрость, которая используется для сокращения числа коллизий: при вычислении хэш-кода умножать промежуточный результат на нечетное простое число. **Чаще всего используется число 29 или 31**.

    @Override
    public int hashCode() {
       int result = model == null ? 0 : model.hashCode();
       result = 31 * result + manufactureYear;
       result = 31 * result + dollarPrice;
       return result;
    }

