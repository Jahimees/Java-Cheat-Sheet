_Источники: _
_https://translated.turbopages.org/proxy_u/en-ru.ru.51b5d52f-666c3b5d-7e48fbfc-74722d776562/https/www.baeldung.com/java-anonymous-classes_

## Анонимные классы

Как было указано тут, анонимные классы - частный случай внутренних классов.

Анонимные классы - это внутренние классы без имени. Поскольку у них нет имени, мы не можем использовать их для создания экземпляров анонимных классов. В результате нам приходится объявлять и создавать экземпляры анонимных классов в одном выражении на этапе использования.

Мы можем либо расширить существующий класс, либо реализовать интерфейс.

### Расширение класса

Когда мы создаем экземпляр анонимного класса на основе существующего, мы используем следующий синтаксис: 

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/e0166fbb-2cb0-48ca-8c2c-9113d91c28bd)

В круглых скобках мы указываем параметры, которые требуются конструктору класса, который мы расширяем:

    new Book("Design Patterns") {
        @Override
        public String description() {
            return "Famous GoF book.";
        }
    }
Естественно, если конструктор родительского класса не принимает аргументов, мы должны оставить круглые скобки пустыми.

### Реализация интерфейса

Мы также можем создать экземпляр анонимного класса из интерфейса:

![image](https://github.com/Jahimees/Java-Cheat-Sheet/assets/36009821/09e077da-138a-4509-8dd1-689360ce7f44)

Очевидно, что интерфейсы Java не имеют конструкторов, поэтому круглые скобки всегда остаются пустыми. Это единственный способ, которым мы должны реализовать методы интерфейса:

    new Runnable() {
        @Override
        public void run() {
            ...
        }
    }

После создания экземпляра анонимного класса мы можем присвоить этот экземпляр переменной, чтобы иметь возможность ссылаться на него где-нибудь позже.
Мы можем сделать это, используя стандартный синтаксис для выражений Java:

    Runnable action = new Runnable() {
        @Override
        public void run() {
            ...
        }
    };

Как мы уже упоминали, **объявление анонимного класса является выражением, следовательно, оно должно быть частью инструкции.** Это объясняет, почему мы поставили точку с запятой в конце инструкции.

Очевидно, что мы можем избежать присвоения экземпляра переменной, если создадим этот экземпляр встроенным:

    List<Runnable> actions = new ArrayList<Runnable>();
    actions.add(new Runnable() {
        @Override
        public void run() {
            ...
        }
    });

+Мы должны использовать этот синтаксис с большой осторожностью, поскольку это может легко ухудшить читаемость кода, особенно когда реализация метода run() занимает много места.

### Свойства анонимного класса

Существуют определенный особенности в использовании анонимных классов по сравнению с обычными классами верхнего уровня. Здесь мы кратко коснемся наиболее практических вопросов. Для получения наиболее точной и обновленной информации обращаться к [спецификации языка Java](https://translated.turbopages.org/proxy_u/en-ru.ru.51b5d52f-666c3b5d-7e48fbfc-74722d776562/https/docs.oracle.com/javase/specs/jls/se8/html/index.html).

#### Конструктор

Синтаксис анонимных классов не позволяет нам заставить их реализовывать несколько интерфейсов. Во время конструирования **может существовать ровно один экземпляр анонимного класса**. Следовательно, они никогда не могут быть абстрактными. Поскольку у них нет имени, мы не можем их расширять. По той же причине анонимные классы не могут иметь явно объявленных конструкторов.

На самом деле, отсутствие конструктора не представляет для нас никакой проблемы по следующим причинам:

1. мы создаем экземпляры анонимных классов в тот же момент, когда их объявляем
2. из экземпляров анонимного класса мы можем получить доступ к локальным переменным и входящим в них членам класса

#### Статические члены

Анонимные классы не могут иметь никаких статических членов, кроме констант.

Например это не сработает:

    new Runnable() {
        static final int x = 0;
        static int y = 0; // compilation error!

        @Override
        public void run() {...}
    };


#### Область действия переменных

Анонимные классы фиксируют локальные перменные, находящиеся в области действия блока, в котором мы объявили класс:

    int count = 1;
    Runnable action = new Runnable() {
        @Override
        public void run() {
            System.out.println("Runnable with captured variables: " + count);
        }           
    };

Как мы видим, локальные переменные count и action определены в одном блоке. По этой причине мы можем получить доступ к count из объявления класса.

Обратите внимание, что для того, чтобы иметь возможность использовать локальные переменные, они должны быть **эффективно конечными** (после инициализации нельзя изменять). Начиная с JDK 8, больше не требуется объявлять переменные с ключевым словом final. Тем не менее, эти переменные должны быть final. В противном случае мы получаем ошибку компиляции:

    [ERROR] local variables referenced from an inner class must be final or effectively final

Для того, чтобы компилятор решил, что переменная на самом деле является неизменяемой, в коде должно быть только одно место, в котором мы присваиваем ей значение. Возможно, мы найдем больше информации об эффективно конечных переменных в статье [“Почему локальные переменные, используемые в лямбда-выражениях, должны быть конечными или Effectively Final?”
](https://translated.turbopages.org/proxy_u/en-ru.ru.51b5d52f-666c3b5d-7e48fbfc-74722d776562/https/www.baeldung.com/java-lambda-effectively-final-local-variables)

Давайте просто упомянем, что, как и любой внутренний класс, анонимный класс может обращаться ко всем членам своего окружающего класса.
