_Источники_
_https://javarush.com/groups/posts/845-lambda-vihrazhenija-na-primerakh_
_https://translated.turbopages.org/proxy_u/en-ru.ru.51b5d52f-666c3b5d-7e48fbfc-74722d776562/https/www.baeldung.com/java-8-streams-introduction_

# Lambda выражения

Lambda-выражения – это анонимные функции (может и не 100% верное определение для Java, но зато привносит некоторую ясность). Проще говоря, это метод без объявления, т.е. без модификаторов доступа, возвращающие значение и имя.

Короче говоря, они позволяют написать метод и сразу же использовать его. Особенно полезно в случае однократного вызова метода, т.к. сокращает время на объявление и написание метода без необходимости создавать класс.

Lambda-выражения в Java обычно имеют следующий синтаксис **(аргументы) -> (тело)**. Например:

    (int a, int b) -> {  return a + b; }
    () -> System.out.println("Hello World");
    (String s) -> { System.out.println(s); }
    () -> 42
    () -> { return 3.1415 };

### Структура Lambda-выражений

* Lambda-выражения могут иметь от 0 и более входных параметров.
* Тип параметров можно указывать явно либо может быть получен из контекста. Например (int a) можно записать и так (a)
* Параметры заключаются в круглые скобки и разделяются запятыми. Например (a, b) или (int a, int b) или (String a, int b, float c)
* Если параметров нет, то нужно использовать пустые круглые скобки. Например () -> 42
* Когда параметр один, если тип не указывается явно, скобки можно опустить. Пример: a -> return a*a
* Тело Lambda-выражения может содержать от 0 и более выражений.
* Если тело состоит из одного оператора, его можно не заключать в фигурные скобки, а возвращаемое значение можно указывать без ключевого слова return.
* В противном случае фигурные скобки обязательны (блок кода), а в конце надо указывать возвращаемое значение с использованием ключевого слова return (в противном случае типом возвращаемого значения будет void).

### Что такое функциональный интерфейс

Для более полного понимания функциональных интерфейсов обратиться [сюда](https://github.com/Jahimees/Java-Cheat-Sheet/blob/main/Java/%D0%A7%D0%B0%D1%81%D1%82%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B5%D0%BC%D1%8B/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B.md).

Functional Interface – это интерфейсы только с одним абстрактным методом, объявленным в нем.

_java.lang.Runnable_ – это пример функционального интерфейса. В нем объявлен только один метод void run(). Также есть интерфейс ActionListener – тоже функциональный. Раньше нам приходилось использовать анонимные классы для создания объектов, реализующих функциональный интерфейс. С Lambda-выражениями, все стало проще.

Каждое lambda-выражение может быть неявно привязано к какому-нибудь функциональному интерфейсу. Например, можно создать ссылку на Runnable интерфейс, как показано в следующем примере:

    Runnable r = () -> System.out.println("hello world");

Подобное преобразование всегда осуществляется неявно, когда мы не указываем функциональный интерфейс:
    
    new Thread(
        () -> System.out.println("hello world") //реализация Runnable с помощью лямбды
    ).start();
    
В примере выше, компилятор автоматически создает lambda-выражение как реализацию Runnable интерфейса из конструктора класса Thread: public Thread(Runnable r) { }.

Аннотация **@FunctionalInterface**, добавленная в Java 8 согласно Java Language Specification, проверяет является ли объявляемый интерфейс функциональным. Кроме того, в Java 8 включен ряд готовых функциональных интерфейсов для использования с Lambda-выражениями. @FunctionalInterface выдаст ошибку компиляции, если объявляемый интерфейс не будет функциональным.

Пример объявления функционального интерфейса:

    @FunctionalInterface
    public interface WorkerInterface {
        public void doSomeWork();
    }

### Отличие Lambda-выражений от анонимных класов

Главное отличие состоит в использовании ключевого слова this. Для **анонимных** **классов** ключевое слово ‘this’ обозначает объект анонимного класса, в то время как в **lambda-выражении ‘this’** обозначает объект класса, в котором lambda-выражение используется.

Другое их отличие заключается в способе компиляции. Java компилирует lambda-выражения с преобразованием их в private-методы класса. При этом используется инструкция invokedynamic, появившаяся в Java 7 для динамической привязки метода.

# Stream

Одной из основных новых функций в Java 8 является внедрение потоковой функциональности – java.util.stream – которая содержит классы для обработки последовательностей элементов. Центральным классом API является Stream<T>. 

### Создание потоков

#### stream() of()
Потоки могут создаваться из различных источников элементов, например коллекций или массивов, с помощью методов stream() и of() :

    String[] arr = new String[]{"a", "b", "c"};
    Stream<String> stream = Arrays.stream(arr);
    stream = Stream.of("a", "b", "c");

#### Collection.stream()
Метод по умолчанию stream() добавлен в интерфейс Collection и позволяет создавать Stream<T> , используя любую коллекцию в качестве источника элементов:

    Stream<String> stream = list.stream();

#### Stream.empty()
Мы должны использовать метод empty() в случае создания пустого потока:

    public Stream<String> streamOf(List<String> list) {
        return list == null || list.isEmpty() ? Stream.empty() : list.stream();
    }

#### Stream.builder()

Желаемый тип должен быть дополнительно указан в правой части инструкции,Когда используется builder, в противном случае метод build() создаст экземпляр Stream<Object>:

    Stream<String> streamBuilder =
      Stream.<String>builder().add("a").add("b").add("c").build();

#### Stream.generate()

Метод generate() принимает Supplier<T> для генерации элемента. Поскольку результирующий поток бесконечен, разработчик должен указать желаемый размер, иначе метод generate() будет работать до тех пор, пока не достигнет предела памяти:

    Stream<String> streamGenerated =
      Stream.generate(() -> "element").limit(10);

Приведенный выше код создает последовательность из десяти строк со значением “элемент”.

#### Stream.iterate()

Другой способ создания бесконечного потока - это использование метода iterate():

      Stream<Integer> streamIterated = Stream.iterate(40, n -> n + 2).limit(20);

Первый элемент результирующего stream является первым параметром метода iterate(). При создании каждого следующего элемента указанная функция применяется к предыдущему элементу. В приведенном выше примере вторым элементом будет 42.

#### Поток примитивов

Java 8 предлагает возможность создавать потоки из трех примитивных типов: int, long и double. Поскольку Stream<T> является универсальным интерфейсом, и нет способа использовать примитивы в качестве параметра типа с generics, были созданы три новых специальных интерфейса: IntStream, LongStream, DoubleStream.

Использование новых интерфейсов устраняет ненужную автоматическую блокировку, что позволяет повысить производительность:

    IntStream intStream = IntStream.range(1, 3);
    LongStream longStream = LongStream.rangeClosed(1, 3);

    Метод range(int startInclusive, int endExclusive) создает упорядоченный поток от первого параметра ко второму параметру. Оно увеличивает значение последующих элементов с шагом, равным 1. Результат не включает последний параметр, это просто верхняя граница последовательности.

Метод rangeClosed(int startInclusive, int endInclusive)  выполняет то же самое, только с одним отличием, включен второй элемент. Мы можем использовать эти два метода для генерации любого из трех типов потоков примитивов.

Начиная с Java 8, класс Random предоставляет широкий спектр методов для генерации потоков примитивов. Например, следующий код создает двойной поток, который состоит из трех элементов:

    Random random = new Random();
    DoubleStream doubleStream = random.doubles(3);

#### Поток строки

Мы также можем использовать String в качестве источника для создания потока с помощью метода chars() класса String. Поскольку в JDK нет интерфейса для CharStream , мы используем IntStream вместо этого для представления потока символов.

    IntStream streamOfChars = "abc".chars();

Следующий пример разбивает строку на подстроки в соответствии с указанным регулярным выражением:

    Stream<String> streamOfString =
      Pattern.compile(", ").splitAsStream("a, b, c");

#### Поток файлов

Более подробно про IO и файлы [тут](https://github.com/Jahimees/Java-Cheat-Sheet/blob/main/Java/%D0%A7%D0%B0%D1%81%D1%82%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B5%D0%BC%D1%8B/Input%20%26%20output%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8.%20File%20IO)

Кроме того, класс Java NIO Files позволяет нам генерировать Stream<String> текстового файла с помощью метода lines(). Каждая строка текста становится элементом потока:

    Path path = Paths.get("C:\\file.txt");
    Stream<String> streamOfStrings = Files.lines(path);
    Stream<String> streamWithCharset = 
      Files.lines(path, Charset.forName("UTF-8"));

Кодировка может быть указана в качестве аргумента метода lines().

### Многопоточность с потоками

Stream API также упрощает многопоточность, предоставляя метод parallelStream(), который выполняет операции над элементами потока в параллельном режиме.

Приведенный ниже код позволяет нам запускать метод DoWork() параллельно для каждого элемента потока:

    list.parallelStream().forEach(element -> doWork(element)); 

В следующем разделе мы представим некоторые основные операции Stream API.

## Операции с потоками

Существует множество полезных операций, которые можно выполнять в потоке.

Они делятся на **промежуточные операции** (возвращают Stream<T>) и **терминальные операции** (возвращают результат определенного типа). Промежуточные операции позволяют создавать цепочки.

Также стоит отметить, что операции с потоками не меняют источник.

Вот краткий пример:

    long count = list.stream().distinct().count();

Итак, метод distinct() представляет собой промежуточную операцию, которая создает новый поток уникальных элементов предыдущего потока. А метод count() - это терминальная операция, которая возвращает размер потока.

### Итерация

Stream API помогает заменять циклы for, for-each и while. Это позволяет сосредоточиться на логике операции, но не на повторении последовательности элементов. Например:

    for (String string : list) {
        if (string.contains("a")) {
            return true;
        }
    }

Эквивалент:

    boolean isExist = list.stream().anyMatch(element -> element.contains("a"));

### Фильтрация

Метод filter() позволяет нам выбирать поток элементов, удовлетворяющих предикату (условию).

Для примера рассмотрим следующий список:

    ArrayList<String> list = new ArrayList<>();
    list.add("One");
    list.add("OneAndOnly");
    list.add("Derek");
    list.add("Change");
    list.add("factory");
    list.add("justBefore");
    list.add("Italy");
    list.add("Italy");
    list.add("Thursday");
    list.add("");
    list.add("");

Следующий код создает поток<String> из списка<String>, находит все элементы этого потока, которые содержат символ “d”, и создает новый поток, содержащий только отфильтрованные элементы:

    Stream<String> stream = list.stream().filter(element -> element.contains("d"));

### Маппинг (map)

Чтобы преобразовать элементы потока, применив к ним специальную функцию, и собрать эти новые элементы в поток, мы можем использовать метод map():

    List<String> uris = new ArrayList<>();
    uris.add("C:\\My.txt");
    Stream<Path> stream = uris.stream().map(uri -> Paths.get(uri));

Итак, приведенный выше код преобразует Stream<String> в Stream<Path> путем применения определенного лямбда-выражения к каждому элементу исходного потока.

_Если у вас есть поток, в котором каждый элемент содержит свою собственную последовательность элементов, и вы хотите создать поток из этих внутренних элементов, вам следует использовать метод flatMap():_

    List<Detail> details = new ArrayList<>();
    details.add(new Detail());
    Stream<String> stream
      = details.stream().flatMap(detail -> detail.getParts().stream());

В этом примере у нас есть список элементов типа Detail. Класс Detail содержит поле PARTS, которое представляет собой Список<Строка>. С помощью метода flatMap() каждый элемент из field PARTS будет извлечен и добавлен в новый результирующий поток. После этого исходный Stream<Detail> будет потерян.

### Matching (Сопоставление, совпадение)

Stream API предоставляет удобный набор инструментов для проверки элементов последовательности в соответствии с некоторым предикатом. Для этого можно использовать один из следующих методов: anyMatch(), allMatch(), noneMatch(). Их названия говорят сами за себя. Это терминальные операции, которые возвращают логическое значение:

    boolean isValid = list.stream().anyMatch(element -> element.contains("h")); // true
    boolean isValidOne = list.stream().allMatch(element -> element.contains("h")); // false
    boolean isValidTwo = list.stream().noneMatch(element -> element.contains("h")); // false

Для пустых потоков метод allMatch() с любым заданным предикатом вернет true:

    Stream.empty().allMatch(Objects::nonNull); // true

Это разумное значение по умолчанию, поскольку мы не можем найти ни одного элемента, который не удовлетворял бы предикату.

Аналогично, метод anyMatch() всегда возвращает false для пустых потоков:

    Stream.empty().anyMatch(Objects::nonNull); // false

Опять же, это разумно, поскольку мы не можем найти элемент, удовлетворяющий этому условию.

## Завершение потока. Stream reduction

API имеет множество терминальных операций, которые сводят поток к типу или примитиву: count(), max(), min(), и sum(). Однако эти операции работают в соответствии с предопределенной реализацией. Ну и что, если разработчику необходимо настроить механизм сокращения потока? Есть два метода, которые позволяют нам сделать это, **методы reduce() и collect().**

### Reducion (сокращение, уменьшение) ТЕРМИНАТОР

Stream API позволяет уменьшить последовательность элементов до некоторого значения в соответствии с заданной функцией с помощью метода reduce() типа Stream. Этот метод принимает два параметра: первый – начальное значение, второй – функцию накопления.

Представьте, что у вас есть List<Integer> и вы хотите получить сумму всех этих элементов и некоторое начальное целое число (в этом примере 23). Итак, вы можете запустить следующий код, и результатом будет 26 (23 + 1 + 1 + 1).

    List<Integer> integers = Arrays.asList(1, 1, 1);
    Integer reduced = integers.stream().reduce(23, (a, b) -> a + b);

Перегрузка метода reduce:

    Optional<T> reduce(BinaryOperator<T> accumulator)
    T reduce(T identity, BinaryOperator<T> accumulator)
    U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)

**identity** – начальное значение для накопителя или значение по умолчанию, если поток пуст и накапливать нечего

**accumulator** – функция, которая задает логику агрегирования элементов. Поскольку накопитель создает новое значение для каждого шага уменьшения, количество новых значений равно размеру потока, и полезно только последнее значение. Это не очень хорошо сказывается на производительности.

**combiner** – функция, которая агрегирует результаты сумматора. Мы вызываем combiner только в параллельном режиме, чтобы уменьшить результаты сумматоров из разных потоков.

_По сути, метод reduce позволяет нам сказать: вот куча элементов, вот правило, по которому это все собирается в один объект_

Примеры:

    OptionalInt reduced = IntStream.range(1, 4).reduce((a, b) -> a + b);

сокращено = 6 (1 + 2 + 3)

    int reducedTwoParams = IntStream.range(1, 4).reduce(10, (a, b) -> a + b);

Сокращено до двух параметров = 16 (10 + 1 + 2 + 3)

    int reducedParams = Stream.of(1, 2, 3)
      .reduce(10, (a, b) -> a + b, (a, b) -> {
         log.info("combiner was called");
         return a + b;
      });

Результат будет таким же, как в предыдущем примере (16), и входа в систему не будет, что означает, что объединитель не вызывался. Чтобы объединитель работал, поток должен быть параллельным:

    int reducedParallel = Arrays.asList(1, 2, 3).parallelStream()
        .reduce(10, (a, b) -> a + b, (a, b) -> {
           log.info("combiner was called");
           return a + b;
        });

Результат здесь другой (36), и объединитель вызывался дважды. Здесь сокращение выполняется по следующему алгоритму: накопитель запускается три раза путем добавления каждого элемента потока в identity. Эти действия выполняются параллельно. В результате у них получилось (10 + 1 = 11; 10 + 2 = 12; 10 + 3 = 13;). Теперь combiner может объединить эти три результата. Для этого требуется две итерации (12 + 13 = 25; 25 + 11 = 36).

### Collecting (сбор) ТЕРМИНАТОР 

Сокращение также может быть обеспечено с помощью метода collect() типа Stream. Эта операция очень удобна в случае преобразования потока в коллекцию или мапу и представления потока в виде одной строки. Существует служебный класс Collectors, который предоставляет решение практически для всех типичных операций сбора данных. Для некоторых, нетривиальных задач, может быть создан пользовательский коллектор .
collect принимает аргумент типа Collector, который определяет механизм сокращения. Для большинства распространенных операций уже созданы предопределенные коллекторы. К ним можно получить доступ с помощью типа Collectors.

    List<String> resultList 
      = list.stream().map(element -> element.toUpperCase()).collect(Collectors.toList());

В этом коде используется операция collect() терминала для уменьшения Stream<String> до List<String>.

В этом разделе мы будем использовать следующий список в качестве источника для всех потоков:

    List<Product> productList = Arrays.asList(new Product(23, "potatoes"),
      new Product(14, "orange"), new Product(13, "lemon"),
      new Product(23, "bread"), new Product(13, "sugar"));

_Преобразование потока в коллекцию (Collection, List или Set):_

    List<String> collectorCollection = 
      productList.stream().map(Product::getName).collect(Collectors.toList());

_Сокращение до строки:_

    String listToString = productList.stream().map(Product::getName)
      .collect(Collectors.joining(", ", "[", "]"));

Метод joiner() может иметь от одного до трех параметров (разделитель, префикс, суффикс). Самое удобное в использовании joiner() заключается в том, что разработчику не нужно проверять, достигает ли поток своего конца, чтобы применить суффикс, а не разделитель. Collector позаботится об этом.

**Обработка среднего значения всех числовых элементов потока:**

    double averagePrice = productList.stream()
      .collect(Collectors.averagingInt(Product::getPrice));

**Обработка суммы всех числовых элементов потока:**

    int summingPrice = productList.stream()
      .collect(Collectors.summingInt(Product::getPrice));

Методы averagingXX(), summingXX() и summarizingXX() могут работать с примитивами (int, long, double) и с их классами-оболочками (Integer, Long, Double). Еще одной мощной функцией этих методов является обеспечение отображения. В результате разработчику не нужно использовать дополнительную операцию map() перед методом collect().

**Сбор статистической информации об элементах stream:**

    IntSummaryStatistics statistics = productList.stream()
      .collect(Collectors.summarizingInt(Product::getPrice));

Используя результирующий экземпляр типа IntSummaryStatistics, разработчик может создать статистический отчет, применив метод toString(). Результатом будет строка, общая для этой “IntSummaryStatistics{count=5, sum= 86, min = 13, average= 17 200000, max = 23}.”

Также легко извлечь из этого объекта отдельные значения для count, sum, min, и average, применив методы getCount(), getSum(), getMin(), getAverage(), и getMax(). Все эти значения могут быть извлечены из одного конвейера.

**Группировка элементов stream в соответствии с указанной функцией:**

    Map<Integer, List<Product>> collectorMapOfLists = productList.stream()
      .collect(Collectors.groupingBy(Product::getPrice));

В приведенном выше примере поток был сведен к карте, которая группирует все продукты по их цене.

**Мы можем использовать только одну терминальную операцию для каждого потока.**
_Правильный и наиболее удобный способ использования потоков - это потоковый конвейер, который представляет собой цепочку из источника потока, промежуточных операций и терминальной операции:_

    List<String> list = Arrays.asList("abc1", "abc2", "abc3");
    long size = list.stream().skip(1)
      .map(element -> element.substring(0, 3)).sorted().count();


### Ленивая работа Streams

**Промежуточные операции выполняются лениво. Это означает, что они будут вызываться только в том случае, если это необходимо для выполнения терминальной операции.**

