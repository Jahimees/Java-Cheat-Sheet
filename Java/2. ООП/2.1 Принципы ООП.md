# 2.1 Принципы ООП

Всюду разнятся принципы: где-то их 4 и добавляют абстракцию, где-то добавляют механизм позднего связывания. Однако 3 непоколебимых принципа должен знать каждый:
* Инкапсуляция
* Наследование
* Полиморфизм
*  + Абстракция
*  + Позднее связывание

## Инкапсуляция 

В теории:
_Инкапсуляция (encapsulation)_ - это механизм, который объединяет данные и код, манипулирующий этими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования.
На практике (чаще всего):
* все поля private (кроме констант). Могут устанавливаться другие модификаторы, но крайне редко;
* к полям предоставляется доступ через get (геттеры - для получения значения) и set (сеттеры - для установки значения) методы:

      public class SimpleExample {
          private int id;

          //Геттер не имеет входных параметров, возвращает значение поля
          public int getId() {
            return id;
          }

          //Сеттер имеет возвращаемый тип - void. Принимаемый - соответствует типу поля
          public void setId(int id) {
            this.id = id;
            //также тут можно сделать проверку перед установкой значения. Но чаще всего перед установкой значения его проверяют до вызова set метода.
            //Все зависит от ситуации. Но не рекомендуется делать проверку в сеттере, поскольку пользователь (как ему кажется) присваивает одно значение, а затем - получает другое
          }
      }

* **set** или **get** методов _может и не быть_, если это обусловлено. Например. Если переменная должна изменяться только внутри класса, то сеттера быть не должно.
* Учитывайте, что _геттер_, который возвращает ссылочный тип, _возвращает копию ССЫЛКИ_, а не _ОБЪЕКТА_ -> **пользователь через get метод может изменять объект**. Такое поведение, зачастую, _неприемлемо_. В идеале возвращать клон объекта (**переопределенный метод clone()**)

## Наследование

Наследование (inheritance) - это процесс, посредством которого, один объект может наследовать свойства другого объекта и добавлять к ним черты, характерные только для него.
Наследование бывает двух видов:
* одиночное - когда каждый класс имеет одного и только одного предка;
* множественное - когда каждый класс может иметь любое количество предков.

Наследуются: 
* методы (если позволяет модификатор доступа)
* поля (если позволяет модификатор доступа).

Например private методы или поля не наследуются. Однако, если у поля есть публичные геттеры или сеттеры, до доступ к переменной можно получить.

Наследование от класса (можно унаследоваться только от 1 класса):

    public class A extends B {...}

Реализация интерфейсов (интерфейсов может быть сколь угодно множество):

    public class A implements B {...} 

где B - интерфейс

**!Важный момент!**
Если класс-наследник определяет свои собственные методы, то при создании ссылки типа родителя, методов наследника видно не будет!!
Есть два класса:

    public class Parent {
      private int id;

      //getter
      //setter
    }

    public class Child extends Parent {
        public void printId() {
          sout(getId());
        }
    }

    psvm() {
      Child child = new Child();
      child.printId(); //сработает

      Parent parentChild = new Child();
      parentChild.printId(); //ошибка компилляции. Необходимо приведение
    }

Решение: определить Parent интерфейсом либо абстрактным классом и определить метод printId(), чтобы он переопределялся классом-наследником (см. полиморфизм)

    public abstract class Parent {
        private int id;

        //getter
        //setter

        public abstract void printId();
    }

    public class Child extends Parent {

        @Override
        public void printId() {
          sout(getId());
        }
    }

    psvm() {
      Child child = new Child();
      child.printId(); //сработает

      Parent parentChild = new Child();
      parentChild.printId(); //теперь тоже сработает
    }

Если поле приватно, то у наследника не будет прямого доступа к этому полю, однако, если будут существовать геттеры и сеттеры, то поле может быть доступно и использованно посредством этих методов:

            public class Parent {

                private int id;

                //геттеры и сеттеры
                public void setId(id) {
                      this.id = id;
                }

                public int getId() {
                      return this.id;
                }
            }

            public class Child extends Parent {

                  public void someMethod() {
                        this.id; //недоступно
                        setId(5); //можно
                        getId(); //можно
                  }
            }

## Полиморфизм

**Полиморфизм (polymorphism)** - это свойство, которое позволяет одно и то же имя использовать для решения двух или более схожих, но технически разных задач.

**Полиморфизм** - один интерфейс, множество реализаций.

В ООП **полиморфизмом** чаще всего называют способность классов с одинаковой спецификацией (интерфейсом) определять различную реализацию, что, в свою очередь, позволяет клиентскому коду абстрагироваться от этой самой реализации и работать с классом, исходя из его спецификации. Например, ваш метод может ожидать получить на входе объект типа UserInterface, при этом не зная, с каким конкретным подтипом типа UserInterface он будет работать.

Пример:

      public interface Parent {

        void printInfo();
      }

      public class Child1 {
        @Override
        public void printInfo() {
         //одна реализация
        }
      }

      public class Child2 {
        @Override
        public void printInfo() {
          //вторая реализация
        }
      }

      public class SomeClass {

        //Метод не знает, что именно он использует - Child1 или Child2
        public void someMethod(Parent parent) {
          parent.printInfo();
        }
      }

## Динамическое связывание

**Динамическое связывание (dynamic binding)** – связывание, при котором ассоциация между ссылкой(именем) и классом не устанавливается, пока объект с заданным именем не будет создан на стадии выполнения программы.
Мы уже разобрались, что в зависимости от ссылки на объект того или иного подкласса, Java вызовет тот или иной _переопределенный метод printInfo()_. Но откуда компилятор знает - какой из методов _printInfo()_ необходимо будет вызвать? Ответ заключается в том, что компилятор этого не знает.
Присоединение вызова метода к телу метода называется связыванием. 

Если связывание производится перед запуском программы (на этапе компиляции или компоновки), оно называется _ранним_ (_early_) или _статическим_ (_static_) связыванием (_binding_).

Неоднозначность в работе метода _someMethod()_ связана именно с ранним связыванием: компилятор не может знать заранее, какой вариант метода _printInfo_() нужно будет вызвать, когда у него есть только ссылка на объект реализацию интерфейса _Parent_ (неизвестно какую).

Данная проблема решается благодаря позднему связыванию, то есть связыванию, проводимому во время выполнения программы, в зависимости от типа объекта. _Позднее (late) связывание (binding)_ также называют _динамическим (dynamic)_ или связыванием на этапе выполнения программы (_runtime binding_).
В реализации Java существует механизм для фактического определения типа объекта во время работы программы для вызова подходящего метода. Иначе говоря, компилятор не знает тип объекта, но механизм вызова метода определяет фактический тип объекта и вызывает соответствующее тело метода.
Для **всех методов** Java **используется механизм позднего связывания**, если только метод не был объявлен как **final** (приватные методы являются **final** по умолчанию).

Итак, подведем итоги:
* статическое связывание в Java происходит на этапе компиляции, тогда как динамическое связывание происходит во время выполнения программы (в runtime);
* для private, final и static методов, а также для полей используется статическое связывание, тогда как для остальных методов (такие методы в некоторых языках программированию называются виртуальными (virtual)) используется динамическое связывание;
* в статическом связывании используется тип ссылки, тогда как в динамическом связывании используется фактический тип объекта;
* перегруженные методы используют статическое связывание, тогда как переопределенные методы используют динамическое связывание.
