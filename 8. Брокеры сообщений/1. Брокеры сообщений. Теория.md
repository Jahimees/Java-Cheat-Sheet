# Основные концепции брокеров сообщений

**Брокер сообщений** (message broker) — это промежуточный сервис, который принимает сообщения от отправителя (producer) и передаёт их получателю (consumer).

* Посредник между сервисами. Позволяет им взаимодействовать асинхронно.
* Например: RabbitMQ, Apache Kafka, ActiveMQ, Amazon SQS, Redis Streams.

**Зачем нужен?**
* Асинхронность: нет блокировки по времени
* Слабая связанность (loose coupling)
* Масштабируемость: сервисы обрабатывают сообщения с нужной скоростью
* Надёжность: сообщения не теряются (если настроено правильно)

Основные понятия

| Понятие                 | Описание                                                                                                |
| ----------------------- | ------------------------------------------------------------------------------------------------------- |
| **Producer**            | Компонент, который отправляет сообщения                                                                 |
| **Consumer**            | Компонент, который получает и обрабатывает сообщения                                                    |
| **Message**             | Само сообщение (обычно в виде JSON или другого формата)                                                 |
| **Queue**               | Очередь сообщений. Сообщения хранятся и потребляются в порядке FIFO                                     |
| **Topic**               | Публикация/подписка (pub/sub). Несколько потребителей могут получать одно и то же сообщение             |
| **Exchange** (RabbitMQ) | Принимает сообщения от продюсера и направляет их в одну или несколько очередей по определённым правилам |
| **Routing Key**         | Ключ маршрутизации — определяет, куда должно быть доставлено сообщение                                  |


Очередь и топик

| Свойство   | Queue                                            | Topic                                            |
| ---------- | ------------------------------------------------ | ------------------------------------------------ |
| Получатели | Один                                             | Много                                            |
| Поведение  | Каждое сообщение читается **одним** потребителем | Каждое сообщение читается **всеми подписчиками** |
| Пример     | Очередь обработки писем                          | Рассылка уведомлений в несколько микросервисов   |

Пример жизненного цикла сообщения

* Сервис A отправляет сообщение в очередь
* Брокер кладёт сообщение в очередь
* Сервис B подписан и читает сообщения
* После обработки — сообщение подтверждается и удаляется (если ack=true)

+Понятия

1. Durable queue / Persistent message
  * Durable queue — сохраняется при перезапуске брокера
  * Persistent message — сообщение пишется на диск (не потеряется при падении)

2. Acknowledgement (ACK)
  * Подтверждение, что сообщение обработано
  * Если не отправить ACK — брокер считает, что сообщение не обработано (можно ретрай)

3. Dead Letter Queue (DLQ)
  * Если сообщение не удалось обработать несколько раз — оно уходит в DLQ
  * Это своего рода «мусорная очередь», куда отправляются проблемные сообщения

**Когда использовать брокеры**
* Медленные операции (PDF, email, billing) — чтобы не держать пользователя
* Многократные получатели одного события (а-ля order_created)
* Интеграция с другими системами через обмен сообщениями

# Основные патерны обмена сообщениями

1. Fire-and-Forget
  * Отправка сообщения без ожидания ответа
  * Часто используется с очередями

Пример: пользователь заказал отчёт → отправили задачу на генерацию PDF → всё

2. Request-Reply (или RPC поверх брокера)
  * Отправитель ждёт ответа
  * У каждого запроса — correlationId и свой replyTo queue

Пример: микросервис A запрашивает у B данные по клиенту через брокер

3. Publish/Subscribe (Fanout)
  * Один отправитель, несколько получателей
  * Подходит для «событийной архитектуры» (event-driven)

Пример: заказ создан → уведомление на email + логирование + учёт аналитики

4. Routing (Direct Exchange)
  * Сообщения направляются по routing key

Пример: ключ order.shipped получает только подписчик по этому ключу

5. Topic-based Routing
  * Можно использовать паттерны маршрутизации, типа order.*, *.created
  * Гибкая фильтрация и распределение сообщений

Пример: order.created попадёт всем, кто слушает order.*

6. Dead Letter Pattern
  * Обработка сообщений, которые не удалось обработать (DLQ)
  * Обычно настраивается через retry + fallback

| Паттерн         | Где полезен                             |
| --------------- | --------------------------------------- |
| Fire-and-Forget | Быстрые, асинхронные задачи             |
| Request-Reply   | Если нужен ответ (RPC-like)             |
| Pub/Sub         | Для событий между несколькими сервисами |
| Routing         | Для фильтрации по ключу                 |
| DLQ             | Для обработки сбоев                     |

| Паттерн                     | Когда использовать                                              | Пример в Spring                           |
| --------------------------- | --------------------------------------------------------------- | ----------------------------------------- |
| **Point-to-Point (Queue)**  | Один отправитель — один получатель. Гарантированная доставка.   | `@RabbitListener(queues = "queue.name")`  |
| **Publish/Subscribe**       | Рассылка одному или многим подписчикам. Обновления или события. | Fanout exchange в RabbitMQ                |
| **Routing (Direct)**        | Когда нужно доставлять сообщение в зависимости от ключа.        | Direct exchange + routing key             |
| **Topics**                  | Гибкая маршрутизация по шаблону (wildcards).                    | Topic exchange (`*.error`, `app.#`)       |
| **Dead Letter Queue (DLQ)** | Обработка сообщений, которые не удалось доставить/обработать.   | DLX + настройка в `RabbitTemplate`        |
| **Retry / Redelivery**      | При временных ошибках — повторная доставка.                     | Spring Retry, `@Retryable`, retry policy  |
| **Message Filter**          | Получатель фильтрует сообщения по определённым условиям.        | Слой логики в `@RabbitListener`           |
| **Aggregator**              | Нужно объединить несколько сообщений в одно.                    | Spring Integration `Aggregator`           |
| **Splitter**                | Деление одного сообщения на несколько.                          | Spring Integration `Splitter`             |
| **Content-Based Router**    | Маршрутизация по содержимому сообщения.                         | Java код/SpEL внутри `MessageHandler`     |
| **Competing Consumers**     | Несколько воркеров читают из одной очереди.                     | Несколько `@RabbitListener` с concurrency |


# RabbitMQ

**Основные сущности RabbitMQ**
* Producer (Производитель) — приложение, которое отправляет сообщения в RabbitMQ.
* Exchange (Обменник) — получает сообщение от производителя и распределяет его по одной или нескольким очередям в зависимости от типа обменника и ключа маршрутизации.
* Queue (Очередь) — место хранения сообщений, ожидающих обработки потребителем.
* Binding (Связь) — правило, связывающее Exchange и Queue, определяющее, какие сообщения и куда попадут.
* Consumer (Потребитель) — приложение, которое подписано на очередь и получает из неё сообщения для обработки.

Типы exchange

1. Direct Exchange
  * Сообщение попадает в очередь, у которой routing key совпадает с ключом, указанным при отправке сообщения.

Пример: routing key = task.save → очередь с binding key task.save

2. Fanout Exchange
  * Рассылает сообщение во все очереди, связанные с обменником. Routing key игнорируется.
  * Используется для широковещательной рассылки.

3. Topic Exchange
  * Позволяет маршрутизировать сообщения по шаблону с использованием символов * (замена одного слова) и # (замена нескольких слов).

Пример: routing key logs.error.db подходит под binding key logs.# или logs.*.db.

4. Headers Exchange (редко используется)
  * Маршрутизирует сообщения по совпадению значений заголовков, а не routing key.

----------

**Основные настройки**
* durable — очередь или exchange сохраняется при перезапуске RabbitMQ (устойчивость).
* auto-delete — очередь/обменник удаляется, когда к ней перестают быть подключены потребители.
* exclusive — очередь доступна только текущему соединению и удаляется при его закрытии.

**Message acknowledgments и retries**
* После получения сообщения потребитель должен подтвердить (ack) его обработку, чтобы RabbitMQ удалил сообщение из очереди.
* Если сообщение не подтверждено (например, при сбое), оно может быть переотправлено другому потребителю (retry).
* Есть механизм Dead Letter Queue (DLQ) — очередь для сообщений, которые не удалось обработать.

**Обработка сообщений и подтверждения (ack)**
* Manual Acknowledgement (Подтверждение вручную)
  * Потребитель после успешной обработки сообщения отправляет подтверждение (ack).
  * Если подтверждения нет, сообщение остается в очереди и может быть переотправлено.
* Auto Acknowledgement
  * RabbitMQ считает сообщение обработанным сразу после отправки потребителю (риск потерять сообщение при сбое).
* Negative Acknowledgement (Nack)
  * Потребитель сообщает о проблеме обработки, и сообщение может быть отправлено в DLQ или переотправлено.

**Работа с DLQ**
* DLQ используется для сбора "проблемных" сообщений.
* Настраивается через аргументы очереди, чтобы при отказе обработки сообщения попадали в DLQ.
* Помогает выявлять и анализировать причины ошибок.

**Особенности доставки и гарантии**
* At most once — сообщение доставлено максимум один раз, возможно потеря.
* At least once — сообщение будет доставлено минимум один раз, возможно дублирование.
* Exactly once — гарантирует доставку ровно один раз (сложно и редко реализуется).

RabbitMQ по умолчанию работает в режиме "at least once" с использованием подтверждений сообщений.

**Что стоит знать мидлу по RabbitMQ**
* Разницу между exchange типами.
* Как настроить очереди и bindings.
* Механизм подтверждения сообщений (ack, nack, requeue).
* Что такое DLQ и зачем он нужен.
* Основы настройки durable и persistence.
* Базовая интеграция с Spring AMQP.
* Возможные проблемы: потеря сообщений, дублирование, зацикливание в DLQ.

**Пример интеграции с Spring Boot (Spring AMQP)**
* Используем spring-boot-starter-amqp.
* Конфигурируем очереди, exchange и binding в @Configuration классе.
* Пишем слушатель с @RabbitListener, который будет принимать и обрабатывать сообщения.
* Управляем подтверждениями сообщений (manual или автоматические).

# Apache Kafka — основы

* Topic — основной объект, куда публикуются сообщения.
* Partition — разбивка топика на несколько частей для масштабирования.
* Offset — уникальный номер сообщения в партиции, позволяющий потребителям отслеживать прогресс.
* Producer — отправляет сообщения в топик.
* Consumer — читает сообщения из топика.
* Consumer Group — группа потребителей, которая совместно читает данные из топика, каждый получает уникальный набор сообщений (партиций).
* Replication — копии партиций для отказоустойчивости.

Отличия

| Фича               | RabbitMQ                                            | Kafka                                                       |
| ------------------ | --------------------------------------------------- | ----------------------------------------------------------- |
| Модель             | Очередь с маршрутизацией через exchange             | Лог-сервис, append-only log по топикам                      |
| Хранение сообщений | В очереди, сообщения удаляются после подтверждения  | Сообщения хранятся долго (конфигурируемо)                   |
| Потребители        | Сообщение доставляется одному потребителю           | Потребители могут читать независимо, каждый со своим offset |
| Масштабируемость   | Горизонтальная, но сложнее                          | Очень масштабируемая, партиции + репликация                 |
| Гарантии доставки  | At least once, можно настроить Exactly once сложнее | Exactly once поддерживается в последних версиях             |
| Использование      | Асинхронное взаимодействие, очереди задач           | Потоковая обработка, большие данные, события                |

**Когда использовать Kafka?**
* Потоковая обработка больших объемов данных
* Нужна высокая масштабируемость и отказоустойчивость
* Сложные event-driven архитектуры и пайплайны данных
* Когда нужно хранить логи и иметь возможность читать их многократно

**Когда лучше RabbitMQ?**
* Классические очереди задач и распределённые системы
* Простая интеграция с микросервисами через сообщения
* Требуется гарантированная доставка с подтверждением
* Сценарии, где порядок сообщений менее критичен
